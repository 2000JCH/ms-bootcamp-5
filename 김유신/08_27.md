# 08/27 회고록
<br>

## final 키워드
- **final 변수**: 값 변경 불가.  
  - 참조형 변수는 참조 자체는 불변이지만 내부 값은 수정 가능  
- **final 메소드**: 오버라이딩 불가 → 상속 시 동작 보장  
- **final 클래스**: 상속 불가 → 불변 객체(String, Integer 등)

---

## 열거형 (Enum)
- 관련 상수를 하나로 묶어 관리  
- 타입 안전성 보장 (컴파일 단계에서 오류 방지)  
- JVM 내에서 각 상수는 단 하나만 존재 → **싱글톤 보장**  
- `필드`, `생성자`, `메소드`를 가질 수도 있음
- **사용 예시**
  ```java
  public enum OrderStatus {
      PENDING("P", "대기중"),
      SHIPPED("S", "배송중");

      private final String code;
      private final String description;

      OrderStatus(String code, String description) {
          this.code = code;
          this.description = description;
      }

      public String getCode() { return code; }
      public String getDescription() { return description; }

      public static OrderStatus fromCode(String code) {
          for (OrderStatus s : values()) {
              if (s.code.equals(code)) return s;
          }
          throw new IllegalArgumentException("Invalid code: " + code);
      }
  }

## 싱글톤 패턴

- 애플리케이션 내에서 하나의 인스턴스만 존재하도록 보장하는 디자인 패턴
- 데이터베이스 연결 모듈, 디스크 연결, 네트워크 통신, DBCP 커넥션풀, 스레드풀 등에 활용

```java
public class DatabaseConnection {
    // 1. private static 인스턴스
    private static DatabaseConnection instance;

    // 2. private 생성자
    private DatabaseConnection() {
        System.out.println("데이터베이스 연결 생성");
    }

    // 3. public static 메소드로 인스턴스 제공
    public static DatabaseConnection getInstance() {
        if(instance == null) {
            instance = new DatabaseConnection();
        }
        return instance;
    }

    public void executeQuery(String query) {
        System.out.println("실행: " + query);
    }
}

// 사용 예제
public class SingletonTest {
    public static void main(String[] args) {
        DatabaseConnection db1 = DatabaseConnection.getInstance();
        DatabaseConnection db2 = DatabaseConnection.getInstance();

        System.out.println(db1 == db2);  // true (같은 인스턴스)

        db1.executeQuery("SELECT * FROM users");
    }
}
```

## 내부클래스

### 멤버 내부 클래스
- 클래스의 멤버 변수 선언부에 위치하고 static 키워드가 없는 내부 클래스
- 외부 클래스의 멤버로 취급되기에 외부 클래스의 객체가 생성된 뒤에 내부 클래스 생성
    - 멤버 내부 클래스가 존재하는 한, **외부 클래스는 CG에 의해 삭제되지 않고 계속 메모리상 존재함**. (**외부 참조**)
- instance 멤버만 선언 가능

### 스태틱 클래스
- static 키워드가 붙은 내부 클래스
- static 클래스 내부에는 instance 멤버와 static 멤버 모두 선언 가능
- 외부 클래스의 인스턴스 멤버에는 접근이 불가하고, 정적(static) 멤버에만 접근 가능
- **외부 참조를 하지 않아** 외부 클래스에 의한 메모리 누수를 예방할 수 있음


### 지역 클래스 
- 메서드 안에서 선언되는 클래스 → 해당 블록 스코프 안에서만 사용 가능

### 익명 클래스
- 클래스 이름이 존재하지 않는 이너 클래스
- 단 하나의 객체만을 생성하는 일회용 클래스
- 클래스의 선언과 동시에 객체를 생성
- 생성자가 존재하지 않음

```java
public class OuterClass {
    private int outerField = 10;
    private static int staticField = 20;

    // 1. 멤버 내부 클래스 (non-static)
    public class InnerClass {
        public void display() {
            System.out.println("외부 필드: " + outerField);  // 외부 클래스 멤버 접근 가능
        }
    }

    // 2. 정적 내부 클래스 (static nested class)
    public static class StaticNestedClass {
        public void display() {
            // System.out.println(outerField);  // 오류: non-static 필드 접근 불가
            System.out.println("정적 필드: " + staticField);  // static 필드만 접근 가능
        }
    }

    // 3. 지역 내부 클래스 (local inner class)
    public void methodWithLocalClass() {
        final int localVar = 30;

        class LocalClass {
            public void display() {
                System.out.println("외부 필드: " + outerField);
                System.out.println("지역 변수: " + localVar);  // final 또는 effectively final만 접근 가능
            }
        }

        LocalClass local = new LocalClass();
        local.display();
    }

    // 4. 익명 내부 클래스 (anonymous inner class)
    public void createAnonymousClass() {
        // 인터페이스를 구현하는 익명 클래스
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("익명 클래스 실행");
            }
        };

        // Java 8+ 람다 표현식으로 대체 가능
        Runnable lambdaRunnable = () -> System.out.println("람다 실행");
    }
}

// 사용 예제
public class InnerClassTest {
    public static void main(String[] args) {
        OuterClass outer = new OuterClass();

        // 멤버 내부 클래스 생성
        OuterClass.InnerClass inner = outer.new InnerClass();
        inner.display();

        // 정적 내부 클래스 생성
        OuterClass.StaticNestedClass nested = new OuterClass.StaticNestedClass();
        nested.display();

        // 지역 내부 클래스
        outer.methodWithLocalClass();

        // 익명 내부 클래스
        outer.createAnonymousClass();
    }
}
```

## String 클래스
### String의 불변성 (Immutable)
- String 객체는 한 번 생성되면 절대 값이 변경되지 않음
- 문자열 수정 시 항상 새로운 객체가 생성됨.
- 리터럴로 생성 시 JVM의 String Pool을 활용하여 동일 문자열을 재사용
- new String("Hello") 는 Heap에 새로운 객체를 생성
```java
String str1 = "Hello";
String str2 = "Hello";
String str3 = new String("Hello");

System.out.println(str1 == str2);      // true (String Pool)
System.out.println(str1 == str3);      // false (다른 객체)
System.out.println(str1.equals(str3)); // true (내용 비교)
```

### 주요 메소드
```java
public class StringExample {
    public static void main(String[] args) {
        String str = "  Hello Java World  ";

        // 길이와 문자 접근
        System.out.println("길이: " + str.length());           // 20
        System.out.println("5번째 문자: " + str.charAt(5));    // 'l'

        // 부분 문자열
        System.out.println(str.substring(8, 12));              // "Java"

        // 검색
        System.out.println(str.indexOf("Java"));               // 8
        System.out.println(str.contains("Java"));              // true
        System.out.println(str.startsWith("  Hello"));         // true
        System.out.println(str.endsWith("World  "));           // true

        // 변환
        System.out.println(str.toLowerCase());                 // 소문자로
        System.out.println(str.toUpperCase());                 // 대문자로
        System.out.println(str.trim());                        // 앞뒤 공백 제거
        System.out.println(str.replace("Java", "Python"));     // 치환

        // 분할과 결합
        String[] words = str.trim().split(" ");
        System.out.println(Arrays.toString(words));            // [Hello, Java, World]

        String joined = String.join("-", words);
        System.out.println(joined);                            // Hello-Java-World

        // 형식화
        String formatted = String.format("이름: %s, 나이: %d", "홍길동", 25);
        System.out.println(formatted);
    }
}
```

### StringBuilder
- 가변(Mutable) 문자열 클래스
- 문자열을 추가/삭제/수정해도 새로운 객체를 생성하지 않음
- 동기화 미지원 → 단일 스레드 환경에서 빠른 성능

### StringBuffer

- StringBuilder와 동일하게 가변(Mutable) 문자열 처리 가능
- 동기화 지원 → 멀티 스레드 환경에서 안전
- 단일 스레드 환경에서는 동기화 때문에 성능이 StringBuilder보다 다소 떨어질 수 있음(큰 차이는 없음)
- StringBuffer 사용 지향


## Math 클래스

- Math 클래스는 모든 메소드가 static -> 객체 생성 없이 사용 가능

```java
public class MathExample {
    public static void main(String[] args) {
        // 기본 연산
        System.out.println("절대값: " + Math.abs(-10));        // 10
        System.out.println("최대값: " + Math.max(10, 20));     // 20
        System.out.println("최소값: " + Math.min(10, 20));     // 10

        // 제곱과 제곱근
        System.out.println("2의 3제곱: " + Math.pow(2, 3));    // 8.0
        System.out.println("16의 제곱근: " + Math.sqrt(16));   // 4.0
        System.out.println("27의 세제곱근: " + Math.cbrt(27)); // 3.0

        // 반올림, 올림, 내림
        double num = 3.7;
        System.out.println("반올림: " + Math.round(num));      // 4
        System.out.println("올림: " + Math.ceil(num));         // 4.0
        System.out.println("내림: " + Math.floor(num));        // 3.0

        // 삼각함수
        double angle = Math.PI / 4; // 45도
        System.out.println("sin(45°): " + Math.sin(angle));
        System.out.println("cos(45°): " + Math.cos(angle));
        System.out.println("tan(45°): " + Math.tan(angle));

        // 로그
        System.out.println("자연로그: " + Math.log(Math.E));   // 1.0
        System.out.println("상용로그: " + Math.log10(100));    // 2.0

        // 난수 생성
        System.out.println("0~1 난수: " + Math.random());

        // 1~100 사이의 정수 난수
        int randomInt = (int)(Math.random() * 100) + 1;
        System.out.println("1~100 난수: " + randomInt);

        // 상수
        System.out.println("원주율: " + Math.PI);
        System.out.println("자연상수: " + Math.E);
    }
}
```
