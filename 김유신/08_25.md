# 08/25 회고록
<br>

## 상속 (Inheritance)
### 정의
- 부모 클래스의 필드와 메소드를 자식 클래스가 물려받는 것
- is-a 또는 kind-of 관계로 표현
- 코드 재사용성과 확장성을 높여줌


### 핵심 특징
- 부모는 자식을 가리킬 수 있다 (업캐스팅)
    - 참조 타입은 부모의 타입, 실제 객체는 자식

- 필드는 타입 기준으로 접근한다

- 메소드는 오버라이딩된 메소드가 호출된다 (동적 바인딩)

### 예시

```java
class Parent{
    public void hi(){
        System.out.println("hi");
    }
    int i=10;
}
class Child extends  Parent{
    int i =20;
    public void run(){
        System.out.println("run");
    }

    public void hi(){
        System.out.println("his");
    }
}
public class Exam01 {
    public static void main(String[] args){
        Parent p = new Child();  //1. 부모는 자식을 가리킬 수 있다.
        System.out.println(p.i); // 2. 필드는 타입 기준으로 접근한다.
        p.hi();               // 3. 메소드는 오버라이딩된 메소드가 호출된다.

        Child c = (Child) p;  // p의 실제 객체는 Child 이므로 다운캐스팅 가능
        System.out.println(c.i); // 참조타입이 Child 이므로 20이 호출
        c.hi();

        c.run();
        //p.run();   -> 불가능. 실제 객체는 Child지만 참조타입이 Parent이므로 Parent에 정의된 내용만 사용 가능
        ((Child)p).run(); // 형변환 해야 사용 가능
    }
}

```
### 결과
```
10
his
20
his
run
```

### super / super()

- super: 부모 클래스 멤버 접근

- super(): 부모 생성자 호출
    - 생성자의 첫 줄에 반드시 위치해야 함
    - 생략 시 자동으로 super() 호출

### 예시
```java
// 부모 클래스
public class Vehicle {
    protected String brand;
    protected String model;
    protected int year;

    public Vehicle(String brand, String model, int year) {
        this.brand = brand;
        this.model = model;
        this.year = year;
    }

    public void start() {
        System.out.println(brand + " " + model + "의 시동을 겁니다.");
    }

    public void stop() {
        System.out.println(brand + " " + model + "의 시동을 끕니다.");
    }

    public void displayInfo() {
        System.out.println("브랜드: " + brand);
        System.out.println("모델: " + model);
        System.out.println("연식: " + year);
    }
}
```

```java
// 자식 클래스
public class Car extends Vehicle {
    private int numberOfDoors;

    public Car(String brand, String model, int year, int numberOfDoors) {
        super(brand, model, year);  // 부모 생성자 호출
        this.numberOfDoors = numberOfDoors;
    }

    // Car만의 고유 메소드
    public void openTrunk() {
        System.out.println("트렁크를 엽니다.");
    }

    @Override
    public void displayInfo() {
        super.displayInfo();  // 부모 메소드 호출
        System.out.println("문 개수: " + numberOfDoors);
    }
}
```
```java
// 또 다른 자식 클래스
public class Motorcycle extends Vehicle {
    private String type;

    public Motorcycle(String brand, String model, int year, String type) {
        super(brand, model, year);
        this.type = type;
    }

    public void wheelie() {
        System.out.println("휠리를 합니다!");
    }

    @Override
    public void displayInfo() {
        super.displayInfo();
        System.out.println("오토바이 타입: " + type);
    }
}
```
```java
public class VehicleTest {
    public static void main(String[] args) {
        Car car = new Car("현대", "소나타", 2023, 4);
        Motorcycle bike = new Motorcycle("할리데이비슨", "스포츠스터", 2022, "크루저");

        System.out.println("=== 자동차 정보 ===");
        car.displayInfo();
        car.start();
        car.openTrunk();
        car.stop();

        System.out.println("\n=== 오토바이 정보 ===");
        bike.displayInfo();
        bike.start();
        bike.wheelie();
        bike.stop();
    }
}
```
### 결과
```
=== 자동차 정보 ===
브랜드: 현대
모델: 소나타
연식: 2023
문 개수: 4
현대 소나타의 시동을 겁니다.
트렁크를 엽니다.
현대 소나타의 시동을 끕니다.

=== 오토바이 정보 ===
브랜드: 할리데이비슨
모델: 스포츠스터
연식: 2022
오토바이 타입: 크루저
할리데이비슨 스포츠스터의 시동을 겁니다.
휠리를 합니다!
할리데이비슨 스포츠스터의 시동을 끕니다.
```


## 메소드 오버라이딩 (Method Overriding)
### 정의

- 부모 클래스의 메소드를 자식 클래스에서 재정의

- 메소드 이름, 매개변수, 반환타입 동일해야 함

- @Override 어노테이션 사용 권장

### 규칙

- 접근 제어자는 부모보다 좁을 수 없다

- 반환 타입은 부모와 같거나 하위 타입만 허용

- static, final, private 메소드는 오버라이딩 불가

### 실행 특징
- 필드는 타입에 따라 접근
- 메소드는 실행 시점의 실제 객체의 타입을 기준으로 동적 바인딩되어 자식의 것이 실행됨


### 예시
```java
package d6_0825;
class Animal{
    public void makeSound() {
        System.out.println("동물이 소리를 냅니다.");
    }

    public void move() {
        System.out.println("동물이 움직입니다.");
    }
}

class Dog extends Animal{
    //말하다
    //먹다
    //움직이다.
    @Override
    public void makeSound() {
        System.out.println("멍멍!");
    }


    @Override
    public void move() {
        System.out.println("강아지가 네 발로 뛰어다닙니다.");
    }


    // Dog만의 고유 메소드
    public void wagTail() {
        System.out.println("꼬리를 흔듭니다.");
    }
}

class Cat extends Animal{
    //말하다
    //먹다
    //움직이다.
    @Override
    public void makeSound() {
        System.out.println("야옹~");
    }

    @Override
    public void move() {
        System.out.println("고양이가 살금살금 걷습니다.");
    }

    public void scratch() {
        System.out.println("할퀴기!");
    }
}

public class OverrideExam {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.makeSound();

        Cat cat = new Cat();
        cat.makeSound();

        Animal animal = null;
        if("1".equals(args[0])){
            animal = new Cat();
        }else{
            animal = new Dog();
        }

        animal.makeSound();
        animal.move();
    }
}
```
### 결과
```
멍멍!
야옹~
야옹~
고양이가 살금살금 걷습니다.
```



## 접근제어자 
- 일반적으로 필드는 private 으로 선언
- 외부에서 이 필드에 접근하려면 public한 getter/setter 메소드를 통해야 함


### getter/setter를 사용하는 이유
1. 캡슐화 및 정보 은닉
    
    - 객체의 내부 구현(필드)을 숨기고, 외부에서는 메소드를 통해서만 접근 가능하게 함 
    - 내부 데이터가 잘못 변경되거나 외부에서 무분별하게 조작되는 것을 막음

2. 데이터 무결성 보장

    - setter에 검증 로직을 넣어 잘못된 값(예: 음수 나이, 비어있는 이름 등)을 차단할 수 있음
    - 단순히 public 필드를 두면 값 검증 불가능

3. 유지보수성
    - 필드 구조가 바뀌더라도 getter/setter를 통해 일관된 인터페이스 제공 가능
    - ex) age를 나중에 birthYear로 바꿔도, getter/setter 내부 로직만 수정하면 외부 코드는 그대로 사용 가능

### 예시
```java
class Person {
    private String name;  // 외부 직접 접근 불가
    private int age;

    public String getName() {
        return name;
    }


    public int getAge() {
        return age;
    }

    public void setName(String name) {
        // 예: 값 검증 로직 추가 가능
        if(name == null || name.isEmpty()) {
            System.out.println("이름은 비어있을 수 없습니다.");
            return;
        }
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

```

## 다형성 (Polymorphism)

### 정의
- 다형성은 하나의 타입으로 여러 객체를 다룰 수 있는 성질을 말한다.
- 프로그램 언어의 각 요소들(상수, 변수, 식, 객체, 메소드 등)이 다양한 자료형에 속할 수 있는 성질.


### 예시 1: 메소드 오버로딩 기반 다형성

```java
System.out.println(10);       // int
System.out.println(3.14);     // double
System.out.println("Hello");  // String
```

- println의 역할은 "출력 후 줄바꿈"으로 동일하지만, 매개변수 타입이 다름
- 즉, 같은 이름의 메소드로 다양한 타입을 처리할 수 있다 → 다형성의 한 예

### 예시 2: 부모 타입으로 자식 참조
```java
Car car = new Bus();
```
- 부모 타입(Car)으로 자식 객체(Bus)를 참조할 수 있다. (업캐스팅)
- 이때 실제 객체의 메소드가 실행되므로, 메소드 오버라이딩과 함께 동적 바인딩이 일어난다.
- 하나의 타입으로 여러 종류의 객체를 다룰 수 있게 한다.


### 다형성 활용 예제
```java 
class Animal {
    public void makeSound() {
        System.out.println("동물이 소리를 냅니다.");
    }
    public void move() {
        System.out.println("동물이 움직입니다.");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("멍멍!");
    }
    @Override
    public void move() {
        System.out.println("강아지가 네 발로 뛰어다닙니다.");
    }
    public void wagTail() {
        System.out.println("꼬리를 흔듭니다.");
    }
}

class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("야옹~");
    }
    @Override
    public void move() {
        System.out.println("고양이가 살금살금 걷습니다.");
    }
    public void scratch() {
        System.out.println("할퀴기!");
    }
}

public class Zoo {
    public static void main(String[] args) {
        // 다형성: 부모 타입으로 자식 객체 참조
        Animal[] animals = new Animal[3];
        animals[0] = new Dog();
        animals[1] = new Cat();
        animals[2] = new Animal();

        System.out.println("=== 동물원의 동물들 ===");
        for(Animal animal : animals) {
            animal.makeSound();  // 오버라이딩된 메소드 호출
            animal.move();
            System.out.println("---");
        }

        // instanceof 연산자 + 다운캐스팅
        for(Animal animal : animals) {
            if(animal instanceof Dog) {
                Dog dog = (Dog) animal;
                dog.wagTail();
            } else if(animal instanceof Cat) {
                Cat cat = (Cat) animal;
                cat.scratch();
            }
        }
    }
}
```

### 실행 결과
```
=== 동물원의 동물들 ===
멍멍!
강아지가 네 발로 뛰어다닙니다.
---
야옹~
고양이가 살금살금 걷습니다.
---
동물이 소리를 냅니다.
동물이 움직입니다.
---
꼬리를 흔듭니다.
할퀴기!
```