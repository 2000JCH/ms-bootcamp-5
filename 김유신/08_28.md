# 08/28 회고록
<br>
<br>

## 1. Collection
- 자바의 자료구조 프레임워크
- 데이터를 효율적으로 저장·검색·삭제할 수 있도록 인터페이스 표준화
- 주요 분류
  - **List**: 순서 O, 중복 허용
  - **Set**: 순서 X, 중복 불허
  - **Map**: 키-값 쌍, 키는 중복 불허 / 값은 중복 허용


## 2. Iterator

- `Iterator`는 컬렉션의 요소를 **순차적으로 접근**하기 위한 인터페이스  
- 모든 컬렉션(`List`, `Set` 등)은 `iterator()` 메서드를 제공하며, 이를 통해 반복문 없이 요소를 하나씩 꺼낼 수 있음  
- `for-each` 문과 달리, **순회 중 안전하게 요소 삭제가 가능** 

### Iterator 주요 메서드
1. `hasNext()`
   - 다음 요소가 존재하면 `true`, 없으면 `false` 반환
2. `next()`
   - 다음 요소를 반환
   - 호출 전 반드시 `hasNext()`로 확인해야 함
3. `remove()`
   - 현재 가리키는 요소를 삭제
   - 순회 중 안전하게 삭제 가능 (for-each에서는 불가능)

### Iterator의 특징
- 인덱스가 없는 컬렉션(Set 등)에서도 사용 가능  
- **단방향 순회**만 가능 (`ListIterator`를 사용하면 양방향 순회 가능)  

### Iterator 예제
```java
import java.util.*;

public class IteratorExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("Java");
        list.add("Spring");
        list.add("JPA");

        Iterator<String> it = list.iterator();

        // 순회
        while(it.hasNext()) {
            String value = it.next();
            System.out.println(value);

            // 특정 요소 삭제
            if(value.equals("Spring")) {
                it.remove(); // 안전한 삭제
            }
        }

        System.out.println("삭제 후 리스트: " + list);
    }
}
```

## 3. Stream

- `Stream`은 자바 8에서 도입된 API로, **컬렉션의 데이터를 선언적이고 함수형 스타일로 처리**할 수 있게 해줌  
- 반복문(`for`, `while`) 대신 내부 반복을 사용하여 더 간결하고 가독성 좋은 코드 작성 가능  
- **원본 데이터를 변경하지 않고** 새로운 결과를 생성 
- 주로 `filter`, `map`, `sorted`, `collect` 등의 연산과 함께 사용

### Stream의 특징
1. **선언적 프로그래밍**
   - "어떻게" 처리할지 대신 "무엇을" 처리할지를 작성
   - 예: `list.stream().filter(x -> x > 10).toList();`

2. **내부 반복**
   - 개발자가 직접 반복문을 제어하지 않고, Stream이 내부적으로 처리

3. **중간 연산과 최종 연산**
   - 중간 연산: `filter`, `map`, `sorted`, `distinct` (결과를 반환하지 않고 Stream을 반환 → 파이프라인 가능)
   - 최종 연산: `forEach`, `collect`, `count` (실제 결과를 반환)


### Stream 주요 메서드
- `filter(Predicate)`: 조건에 맞는 요소만 필터링
- `map(Function)`: 요소를 변환
- `distinct()`: 중복 제거
- `sorted()`: 정렬
- `limit(n)`: n개까지만 가져오기
- `forEach(Consumer)`: 각 요소에 대해 동작 수행
- `collect(Collectors.toList())`: 결과를 리스트로 수집

### Stream 예제
```java
import java.util.*;
import java.util.stream.*;

public class StreamExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Kim", "Lee", "Park", "Lee", "Choi");

        // 1. 중복 제거 후 정렬하여 출력
        names.stream()
             .distinct()
             .sorted()
             .forEach(System.out::println);

        // 2. 특정 조건 필터링 (L로 시작하는 이름만)
        List<String> lNames = names.stream()
                                   .filter(n -> n.startsWith("L"))
                                   .toList();
        System.out.println("L로 시작하는 이름: " + lNames);

        // 3. map을 이용한 변환 (대문자로 변경)
        List<String> upperNames = names.stream()
                                       .map(String::toUpperCase)
                                       .toList();
        System.out.println("대문자 변환: " + upperNames);

        // 4. 병렬 처리 예제
        long count = names.parallelStream()
                          .filter(n -> n.length() >= 4)
                          .count();
        System.out.println("길이가 4 이상인 이름 개수: " + count);
    }
}
```

## 4. List

- `List` 인터페이스는 자바 컬렉션 프레임워크의 일부로, **순서가 있는 시퀀스(Sequence)** 를 표현
- **중복 허용**: 동일한 요소를 여러 번 저장할 수 있음
- **인덱스 접근 가능**: 각 요소는 인덱스로 관리되므로 특정 위치에 빠르게 접근 가능  
- 순서가 중요한 경우, 혹은 동일한 데이터를 여러 번 다뤄야 할 때 유용

### List 주요 구현체
1. **ArrayList**
   - 내부적으로 **동적 배열**을 사용
   - 인덱스를 통한 **빠른 임의 접근** 가능
   - 단, 요소 삽입·삭제 시 다른 요소들의 이동이 필요해 성능 저하 가능

2. **LinkedList**
   - **이중 연결 리스트** 구조
   - 삽입과 삭제는 빠르지만, 임의 접근 속도는 느리다

3. **Vector**
   - ArrayList와 비슷하지만, **동기화(synchronized)** 지원
   - 멀티스레드 환경에서 안전하지만 성능은 느림

4. **Stack**
   - Vector를 상속한 클래스
   - **후입선출(LIFO)** 구조의 자료 저장 방식


### List 예제
```java
import java.util.*;

public class ListExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();

        // 요소 추가
        list.add("Java");
        list.add("Spring");
        list.add("Java"); // 중복 허용

        // 접근
        System.out.println(list.get(0)); 

        // 수정
        list.set(1, "Spring Boot");

        // 삭제
        list.remove("Java"); // 첫 번째 Java만 삭제됨

        // 출력
        for(String s : list) {
            System.out.println(s);
        }
    }
}
```


## 5. Set

- `Set` 인터페이스는 자바 컬렉션 프레임워크의 일부로, **순서가 없고 중복을 허용하지 않는** 집합(Collection)을 표현
- **중복 불허**: 동일한 요소는 하나만 저장됨
- **인덱스 없음**: 요소는 인덱스로 접근할 수 없으며, 대신 `Iterator`나 `for-each`를 사용해 순회
- 원소의 유일성이 중요한 경우에 적합 (예: 회원 ID 목록, 중복 제거)

### Set 주요 구현체
1. **HashSet**
   - 해시 테이블 기반
   - 가장 많이 사용되는 Set
   - 순서 보장 없음

2. **LinkedHashSet**
   - HashSet과 동일하지만, **입력 순서를 유지**

3. **TreeSet**
   - 이진 검색 트리 기반
   - 자동 정렬 지원 (기본 정렬 또는 `Comparator` 사용)

### Set 사용 시 주의
- Set의 중복 판단은 **`equals()`와 `hashCode()`** 메서드로 이루어짐  
- String은 이미 오버라이딩되어 값 기준으로 비교 가능  
- 직접 만든 객체를 저장하려면 `equals`와 `hashCode`를 반드시 오버라이딩해야 함

### Set 예제
```java
import java.util.*;

public class SetExample {
    public static void main(String[] args) {
        Set<String> set = new HashSet<>();

        // 요소 추가
        set.add("Java");
        set.add("Spring");
        set.add("Java"); // 중복 무시

        // 크기 확인
        System.out.println("크기: " + set.size()); // 2

        // 순회
        for(String s : set) {
            System.out.println(s);
        }
    }
}
```
## 6. Map

- `Map` 인터페이스는 **키-값(Key-Value) 쌍**으로 데이터를 저장하는 자료구조
- **키는 중복 불허**, 값은 중복 허용
- 키를 이용해 값을 빠르게 검색할 수 있어 효율적
- 예: 아이디-비밀번호 매핑, 상품코드-상품명 매핑 등

### Map 주요 구현체
1. **HashMap**
   - 해시 테이블 기반
   - 가장 일반적으로 사용
   - 순서 보장 없음

2. **LinkedHashMap**
   - HashMap과 유사하지만, **입력된 순서 유지**

3. **TreeMap**
   - 이진 검색 트리 기반
   - 키를 기준으로 자동 정렬

4. **Hashtable**
   - 오래된 클래스
   - 동기화(synchronized) 지원
   - 최근에는 잘 사용되지 않음

### Map 예제
```java
import java.util.*;

public class MapExample {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();

        // 데이터 추가
        map.put("Java", 1);
        map.put("Spring", 2);
        map.put("Java", 3); // 키 중복 → 값 덮어쓰기

        // 값 접근
        System.out.println(map.get("Java")); // 3

        // 데이터 삭제
        map.remove("Spring");

        // 순회
        for(String key : map.keySet()) {
            System.out.println(key + " = " + map.get(key));
        }
    }
}
```
