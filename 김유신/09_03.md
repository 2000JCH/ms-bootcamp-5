# 09/03 회고록
## 자바 예외 처리


### 1. Checked Exception vs RuntimeException

#### Checked Exception
- RuntimeException외의 일반적인 Exception을 상속하는 경우
- 컴파일러가 예외 처리를 강제
- 주로 외부 자원 문제에서 발생 (파일, DB, 네트워크 등)
- 예시: IOException, SQLException
```java
public void readFile(String path) throws IOException {
    FileReader fr = new FileReader(path); // 반드시 처리 필요
}
```
#### RuntimeException (Unchecked Exception)
- RuntimeException을 상속한 예외
- 컴파일러가 강제하지 않음
- 예시: NullPointerException, ArithmeticException
```java
public int divide(int a, int b) {
    return a / b; // b=0이면 ArithmeticException 발생
}
```

### 2. 직접 처리 (try-catch 계열)
- 예외가 발생했을 때 해당 코드 블록 안에서 바로 잡아서 처리

#### try-catch-(finally)
```java
//try-catch
try {
    int result = 10 / 0; // ArithmeticException 발생
} catch (ArithmeticException e) {
    System.out.println("0으로 나눌 수 없습니다: " + e.getMessage());
}

//try-catch-finally
FileReader fr = null;
try {
    fr = new FileReader("test.txt");
    int data = fr.read();
} catch (IOException e) {
    System.out.println("파일 읽기 오류: " + e.getMessage());
} finally {
    if (fr != null) {
        try { fr.close(); } catch (IOException e) {}
    }
}
```

- 예외가 발생하면 catch 블록에서 해당 예외를 잡아 처리
- finally 블록은 예외 발생 여부와 관계없이 항상 실행
    - 자원 해제 등에 주로 사용

#### try-with-resources
```java
try (FileReader fr = new FileReader("test.txt")) {
    int data = fr.read();
} catch (IOException e) {
    System.out.println("파일 읽기 실패");
}
```
- AutoCloseable을 구현한 객체를 자동으로 닫아줌
- try에 ()로 관리할 객체를 넣어줌;


#### 직접 처리를 쓰는 경우
- 예외를 즉시 복구할 수 있을 때 (예: 잘못된 사용자 입력 → 재입력 요청)
- 프로그램 흐름을 중단시키지 않고 계속 진행해야 할 때
- 자원 해제가 필요한 경우 (파일 닫기, DB 연결 종료 등)
- 라이브러리 내부에서 사용자에게 구체적인 메시지를 주고 싶을 때


### 3. 호출자에게 위임 (throws)
- 현재 메서드에서 예외를 해결하지 않고, 호출한 쪽에서 처리
- 메서드 선언부에 throws를 명시해야 함

```java
// 예외를 선언부에 명시
public void readFile(String path) throws IOException {
    FileReader fr = new FileReader(path);
}

// 호출부
try {
    readFile("test.txt");
} catch (IOException e) {
    System.out.println("파일을 열 수 없습니다");
}
```
- 메서드에서 예외를 직접 처리하지 않고 호출한 쪽으로 예외를 넘김
- Checked Exception에서는 필수적으로 사용되며, 호출자가 반드시 처리

### throws를 쓰는 경우
- 현재 메서드에서 해결하기 힘들 때
- 호출자가 더 많은 문맥 정보를 가지고 처리해야 할 때 (UI, 로깅, 사용자 안내 등)
- Checked Exception일 때


## 자바 IO 


### 자바 IO의 설계 철학
- 자바 I/O는 입출력 처리를 범용적이고 확장성 있게 하기 위해 설계됨
- 유연성: 파일, 네트워크, 메모리 등 다양한 소스/대상을 동일한 스트림 인터페이스로 처리 가능
- 확장성: 새로운 스트림 타입을 추가하거나 기존 기능을 래핑하여 확장하기 쉬움(Decorator 패턴 활용)
- 재사용성: 일관된 클래스 구조를 통해 코드를 다양한 환경에서 재활용할 수 있고, 유지보수도 용이

### 자바 IO 설계 패턴 — Decorator

- 주인공(Stream 본체): 실제 데이터 소스/대상(파일, 소켓, 배열 등)과 직접 연결되는 스트림
- 장식자(Decorator): 다른 스트림을 매개변수로 받아 기능을 확장
    - 생성자에 실제 데이터가 들어오면 주인공,  다른 IO 객체를 받으면 장식자로 구분

``` java
FileInputStream fis = new FileInputStream("data.txt");        // 주인공
BufferedInputStream bis = new BufferedInputStream(fis);       // 장식자
```

- FileInputStream은 실제 파일에서 바이트를 읽어옴
- BufferedInputStream을 통해 버퍼로 변환

### 스트림(Stream)의 개념
- 데이터가 흐르는 통로를 의미
- 입력은 InputStream/Reader, 출력은 OutputStream/Writer로 구분된다.

[데이터 소스] → 입력 스트림 → [프로그램] → 출력 스트림 → [데이터 대상]


### 4. 스트림의 분류
1. 데이터 단위에 따라
    - 바이트 스트림 (InputStream/OutputStream) → 1바이트 단위. 이진 데이터(이미지, 영상 등) 처리
    - 문자 스트림 (Reader/Writer) → 문자 단위. 텍스트 데이터 처리

2. 데이터 흐름에 따라
    - 입력 스트림: 소스에서 프로그램으로 읽기
    - 출력 스트림: 프로그램에서 대상으로 쓰기

### 바이트 단위 입출력
- 모든 데이터를 표현할 수 있는 가장 기본적인 스트림
- 1바이트씩 처리
- 이진 데이터(이미지, 오디오, 영상 등)를 처리하는 데 적합

``` java
try (FileInputStream in = new FileInputStream("input.jpg");
     FileOutputStream out = new FileOutputStream("output.jpg")) {

    int byteData;
    while ((byteData = in.read()) != -1) {
        out.write(byteData);
    }
    System.out.println("파일 복사 완료!");
} catch (IOException e) {
    e.printStackTrace();
}
```
### 문자 단위 입출력
- 텍스트 처리에 최적화된 스트림
- 문자셋(Encoding)을 자동으로 처리해 유니코드 기반 다국어 지원 가능

```java
try (FileReader reader = new FileReader("input.txt");
     FileWriter writer = new FileWriter("output.txt")) {

    int ch;
    while ((ch = reader.read()) != -1) {
        writer.write(ch);
    }
    System.out.println("텍스트 파일 복사 완료!");
} catch (IOException e) {
    e.printStackTrace();
}
```