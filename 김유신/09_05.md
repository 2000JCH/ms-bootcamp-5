# 09/05 회고록
<br>
<br>

## 객체지향 프로그래밍 핵심 개념

### 1. 추상화 (Abstraction)
- 복잡한 시스템을 단순화하여 핵심 속성과 기능만 드러냄
- 구체적 세부 구현은 감추고 인터페이스만 노출

### 2. 캡슐화 (Encapsulation)
- 속성과 메서드를 하나로 묶고 외부 접근을 제한
- 내부 구현은 숨기고 인터페이스만 제공

### 3. 상속 (Inheritance)
- 부모 클래스의 속성과 메서드를 자식이 물려받아 사용
- 필요 시 재정의(Override)나 확장 가능

### 4. 다형성 (Polymorphism)
- 동일한 메서드 호출이 객체의 실제 타입에 따라 다르게 동작
- 다형성을 통해 유연성과 재사용성 확보


## SOLID 원칙 개요
- **S** : 단일 책임 원칙 (SRP)  
- **O** : 개방-폐쇄 원칙 (OCP)  
- **L** : 리스코프 치환 원칙 (LSP)  
- **I** : 인터페이스 분리 원칙 (ISP)  
- **D** : 의존성 역전 원칙 (DIP)  


## 1. SRP (Single Responsibility Principle)
- 클래스는 단 하나의 책임만 가져야 함
- 변경 이유는 단 하나여야 함
- 여러 책임이 섞여 있으면, 하나를 수정하다가 다른 기능에 영향을 줄 수 있음
- 장점: **유지보수 용이, 테스트 용이성, 확장성**
```java
//잘못된 예: 파일 읽기와 데이터 파싱을 동시에 수행
class DataProcessor {
    void readFile(String path) { ... }
    void parseData(String raw) { ... }
}

//올바른 예: 책임을 분리
class FileReader {
    String read(String path) { ... }
}

class DataParser {
    void parse(String raw) { ... }
}
```

## 2. OCP (Open/Closed Principle)
- 확장에는 열려 있고, 수정에는 닫혀 있어야 함
- 리그레션(새 코드 때문에 기존 기능이 깨지는 문제) 예방
- 장점: **기존 코드 수정 없이 새 기능 추가 용이**
```java
//잘못된 예: 동물을 추가할 때마다 코드를 수정해야 함
class Animal {
    void makeSound(String type) {
        if (type.equals("dog")) System.out.println("Woof");
        else if (type.equals("cat")) System.out.println("Meow");
    }
}

//올바른 예: 다형성으로 확장 가능
interface Animal {
    void makeSound();
}

class Dog implements Animal {
    public void makeSound() { System.out.println("Woof"); }
}

class Cat implements Animal {
    public void makeSound() { System.out.println("Meow"); }
}
```


## 3. LSP (Liskov Substitution Principle)
- 자식 클래스는 부모 클래스를 대체할 수 있어야 함
- 상속은 “is-a 관계”일 때만 사용
- 장점: **다형성 보장, 코드 변경 시 오류 최소화**
```java
//잘못된 예: 타조는 날 수 없는데 fly()를 상속받음 → LSP 위반
class Bird {
    void fly() { System.out.println("Flying"); }
}

class Ostrich extends Bird {
}

//올바른 예: 날 수 있는 새와 날 수 없는 새를 분리
interface Flyable {
    void fly();
}

class Sparrow implements Flyable {
    public void fly() { System.out.println("Flying"); }
}

class Ostrich {
    void run() { System.out.println("Running"); }
}

```

## 4. ISP (Interface Segregation Principle)
- 클라이언트는 사용하지 않는 메서드에 의존하지 않아야 함
- 큰 인터페이스를 잘게 나누어 필요한 기능만 제공
- 장점: **독립성, 변경에 강함, SRP와 연결**
```java
//잘못된 예: 너무 큰 인터페이스
interface Worker {
    void work();
    void eat();
}

class Robot implements Worker {
    public void work() { ... }
    public void eat() { ... } 
}

//올바른 예: 인터페이스 분리
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

class Human implements Workable, Eatable {
    public void work() { ... }
    public void eat() { ... }
}

class Robot implements Workable {
    public void work() { ... }
}
```

## 5. DIP (Dependency Inversion Principle)
- 상위 모듈은 하위 구현체에 의존하지 않고 추상화에 의존
- 세부사항이 추상화에 의존하도록 의존 방향을 역전
- 장점: **유연성, 확장성, 구현체 교체 용이**

```java
//잘못된 예: 고수준 모듈이 저수준 모듈에 직접 의존
class MySQLDatabase {
    void save(String data) { ... }
}

class UserService {
    private MySQLDatabase db = new MySQLDatabase();
    void saveUser(String user) {
        db.save(user);
    }
}

//올바른 예: 인터페이스를 통해 의존성 역전
interface Database {
    void save(String data);
}

class MySQLDatabase implements Database {
    public void save(String data) { ... }
}

class MongoDatabase implements Database {
    public void save(String data) { ... }
}

class UserService {
    private Database db;
    UserService(Database db) {
        this.db = db;
    }
    void saveUser(String user) {
        db.save(user);
    }
}
```

## 실습문제1 SRP  리펙토링
```java
package day13;

import java.util.*;

//도메인 모델
final class Employee {
    private final String name;
    private final double salary;
    public Employee(String name, double salary) {
        this.name = name;
        this.salary =salary;
    }
    public String getName() { return name; }
    public double getSalary() { return salary; }
}

//급여 계산 정책
interface PayCalculator {
    double calculate(Employee e);
}

final class DefaultBonus10Calculator implements PayCalculator {
    public double calculate(Employee e) {

        return e.getSalary()*1.1;
    }
}

//저장소
interface EmployeeRepository {
    void save(Employee e);
    Optional<Employee> findByName(String name);
    List<Employee> findAll();
}

final class InMemoryEmployeeRepository implements EmployeeRepository {
    private final Map<String, Employee> store = new HashMap<>();
    public void save(Employee e) { store.put(e.getName(), e); }
    public Optional<Employee> findByName(String name) { return Optional.ofNullable(store.get(name)); }
    public List<Employee> findAll() { return new ArrayList<>(store.values()); }
}

//보고서 생성
interface ReportGenerator {
    String generate(Employee e, double pay);
}

final class SimpleTextReport implements ReportGenerator {
    public String generate(Employee e, double pay) {
        return "Employee Report\n" +
                "- name: " + e.getName() + "\n" +
                "- baseSalary: " + e.getSalary() + "\n" +
                "- calculatedPay: " + pay + "\n";
    }
}

//비즈니스 로직 처리
final class PayrollService {
    private final PayCalculator calculator;
    private final EmployeeRepository repository;
    private final ReportGenerator reportGenerator;

    public PayrollService(PayCalculator calculator,
                          EmployeeRepository repository,
                          ReportGenerator reportGenerator) {
        this.calculator = calculator;
        this.repository = repository;
        this.reportGenerator = reportGenerator;
    }

    public double process(Employee e) {
        double pay = calculator.calculate(e);
        repository.save(e);
        System.out.println(reportGenerator.generate(e, pay));
        return pay;
    }
}

//main
public class EmployeeTest {
    public static void main(String[] args) {
        Employee e = new Employee("유신", 1_000_000);
        PayrollService svc = new PayrollService(
                new DefaultBonus10Calculator(),
                new InMemoryEmployeeRepository(),
                new SimpleTextReport());

        double pay = svc.process(e);
        System.out.println("pay : " + pay+ "원");
    }
}
```