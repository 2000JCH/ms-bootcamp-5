# 09/10 회고록
## SELECT 정리

### SELECT 기본 문법
```sql
SELECT 컬럼리스트
FROM 테이블명
[WHERE 조건]
[GROUP BY 그룹기준]
[HAVING 그룹조건]
[ORDER BY 정렬기준]
[LIMIT 갯수 OFFSET 시작위치];
SELECT: 가져올 컬럼 지정

FROM: 데이터를 가져올 테이블

WHERE: 조건으로 행 필터링

GROUP BY: 같은 값을 묶음

HAVING: 그룹 조건

ORDER BY: 정렬

LIMIT: 결과 개수 제한
```

### SELECT 기타 문법
``` sql
-- 전체 컬럼 조회
SELECT * FROM employees;

-- 특정 컬럼 조회
SELECT first_name, last_name FROM employees;

-- 컬럼 연산과 별칭
SELECT first_name, salary * 12 AS annual_salary
FROM employees;

-- 중복 제거 (DISTINCT)
SELECT DISTINCT department_id
FROM employees;

-- WHERE 조건 검색 
SELECT * FROM employees
WHERE salary >= 3000;

-- 논리 연산자
SELECT * FROM employees
WHERE department_id = 10 OR department_id = 20;

-- IN 연산자
SELECT * FROM employees
WHERE department_id IN (10, 20, 30);

-- BETWEEN
SELECT * FROM employees
WHERE salary BETWEEN 3000 AND 5000;

-- LIKE 패턴 매칭 
-- % : 임의의 문자열
-- _ : 임의의 한 글자
SELECT * FROM employees
WHERE first_name LIKE 'J%';   -- J로 시작

SELECT * FROM employees
WHERE last_name LIKE '_a%';   -- 두 번째 글자가 a

-- NULL 처리 
-- NULL 확인
SELECT * FROM employees
WHERE commission_pct IS NULL;

-- NULL 대체
SELECT first_name, IFNULL(commission_pct, 0) AS comm
FROM employees;

-- 정렬 (ORDER BY) 
-- 단일 컬럼 정렬
SELECT * FROM employees
ORDER BY salary DESC;

-- 다중 컬럼 정렬
SELECT * FROM employees
ORDER BY department_id ASC, salary DESC;

-- 결과 제한 (LIMIT)
-- LIMIT
SELECT * FROM employees LIMIT 5;

-- LIMIT + OFFSET
SELECT * FROM employees LIMIT 5 OFFSET 10;

-- SQL 함수 
-- 문자열 함수
SELECT UPPER(first_name), LOWER(last_name),
       CONCAT(first_name, ' ', last_name) AS full_name
FROM employees;

-- 숫자 함수
SELECT ABS(-10), ROUND(123.456, 2), CEIL(4.1), FLOOR(4.9);

-- 날짜 함수
SELECT NOW(), CURDATE(), CURTIME(),
       DATE_ADD(CURDATE(), INTERVAL 10 DAY),
       DATEDIFF(CURDATE(), '2025-01-01');

-- 집계 함수
SELECT COUNT(*) AS 총원,
       AVG(salary) AS 평균급여,
       MAX(salary), MIN(salary), SUM(salary)
FROM employees;

-- GROUP BY
SELECT department_id, AVG(salary) AS 평균급여
FROM employees
GROUP BY department_id;

-- HAVING
SELECT department_id, COUNT(*) AS 인원
FROM employees
GROUP BY department_id
HAVING COUNT(*) >= 5;
```

## JOIN 

### JOIN 개념 
- JOIN은 하나 이상의 테이블에서 **연관된 데이터**를 검색하기 위해 사용하는 방법
- 논리적으로는 두 테이블의 **카티션 곱(Cartesian Product)** 을 만든 후, 조건에 맞는 행만 남기는 방식으로 동작
- 실제 DBMS는 효율적인 조인 알고리즘(인덱스 탐색, 해시 조인 등)을 사용


### JOIN 종류
- **Cross Join** : 조건 없이 모든 가능한 행의 조합 (카티션 곱)  
- **Inner Join** : 조인 조건을 만족하는 행만 결과에 포함  
- **Outer Join** : 조건 불일치 행도 NULL과 함께 포함 (LEFT, RIGHT, FULL)  
- **Self Join** : 자기 자신과 조인 (계층/상하관계 표현)  


### Cartesian Join (Cross Join) 
- 조인 조건이 없거나 잘못 지정된 경우 발생하며, `m`행 × `n`행 → `m*n`행 결과 출력 

```sql
-- 잘못된 조인 (조건 없음)
SELECT * FROM employees, departments;
-- employees 107명 × departments 27개 부서 = 2,889행
```

### Simple Join
```sql
SELECT 
    e.first_name,
    e.last_name,
    d.department_name
FROM employees e, departments d
WHERE e.department_id = d.department_id;
```
### ANSI JOIN 
```sql
-- JOIN ~ ON
SELECT e.first_name, e.last_name, d.department_name
FROM employees e
JOIN departments d ON e.department_id = d.department_id;

-- JOIN ~ USING (컬럼명이 동일할 때)
SELECT e.first_name, e.last_name, d.department_name
FROM employees e
JOIN departments d USING (department_id);

-- NATURAL JOIN (공통 컬럼 자동 매칭)
SELECT * 
FROM employees NATURAL JOIN departments;
```

