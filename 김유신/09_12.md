# 09/12 회고록

## 인덱싱 (Indexing)
- 빠른 검색을 위해 별도의 인덱스 테이블을 생성하는 것으로, 비교 횟수를 줄여 조회 성능을 높임
- InnoDB 기본 구조: B+Tree(다진 균형 트리)
- WHERE / JOIN / ORDER BY / GROUP BY 등의 조회관련 쿼리 실행시 효율적
- INSERT/UPDATE/DELETE 등의 쿼리 실행시 인덱스 테이블을 수정해야하기에 더 느려짐 + 메모리사용 늘어남

### 클러스터드 인덱스 vs 넌클러스터드 인덱스
#### 1) 클러스터드 인덱스
<img width="937" height="567" alt="Image" src="https://github.com/user-attachments/assets/0ecc2f7c-2893-4317-9695-58761508fcce" />

- 트리로 저장되며, Root페이지와 Leaf페이지로 구성
- 행 데이터를 해당 열로 정렬한 후에, Root페이지를 만듬 (물리적으로 행을 재배열)
- Root페이지는 Leaf페이지의 주소로 구성하고, Leaf페이지는 실제 데이터 페이지로 구성
- 별도 본문 재조회가 없음
- PK가 길면 테이블 자체가 커져 전반적 공간/쓰기 비용이 증가
- 조회시엔 빠르지만 입력, 수정 등은 느림

#### 2) 넌클러스터드 인덱스
<img width="827" height="622" alt="Image" src="https://github.com/user-attachments/assets/e109e36e-a6c2-42ba-8d9b-f479f05c6ab2" />

- 레코드의 원본은 정렬되지 않고, 인덱스 페이지만 정렬됨
- 인덱스 페이지의 리프 페이지에 Index로 구성한 열을 정렬한 후 위치 포인터(RID)를 생성
  - 포인터(RID): '파일그룹번호+데이터페이지 번호 + 페이지 내의 로우 번호'으로 구성되는 포인팅 정보
  - 별도의 인덱스 페이지를 따로 만들기 때문에 용량을 더 차지함
- 클러스터형보다 검색 속도는 더 느리지만 데이터의 입력, 수정, 삭제는 더 빠름



## 트랜잭션 (Transactions)

- DB의 상태를 변경시키기 위해 수행하는 작업 단위
- 여러 SQL을 **한 덩어리(원자적 단위)**로 묶어 ACID(원자성·일관성·격리성·지속성) 보장

### ACID
- 원자성(Atomicity): 전부 성공하거나 전부 실패(롤백).
- 일관성(Consistency): 규칙(제약조건 등)을 항상 만족.
- 격리성(Isolation): 동시 실행이 서로 간섭하지 않도록.
- 지속성(Durability): 커밋된 내용은 장애에도 유지.

### 기본 동작
- autoCommit=true(기본) → 문장 단위 자동 커밋
- autoCommit=false 또는 START TRANSACTION → 같은 커넥션에서 COMMIT/ROLLBACK까지가 한 트랜잭션
- DDL(예: CREATE/ALTER/DROP/TRUNCATE) 은 암묵적 커밋이 발생해 트랜잭션 바깥처럼 동작(롤백 불가로 이해).


## JDBC (Java Database Connectivity)
-   Java 애플리케이션에서 데이터베이스에 접속하고 SQL을 실행하기 위한 표준 API

### JDBC 구성 요소
- DriverManager	JDBC 드라이버 관리, Connection 생성
- Connection : 데이터베이스 연결
- Statement :	SQL 문장 실행
- PreparedStatement	: 미리 컴파일된 SQL 실행
- CallableStatement	: 저장 프로시저 실행
- ResultSet	: SELECT 결과 저장

- try-with-resources로 Connection / (Prepared)Statement / ResultSet을 닫아어야 함


### Statement vs PreparedStatement
- Statement: 문자열 전체를 매번 전송/파싱. 인젝션 위험, 반복 실행 비효율.
- PreparedStatement: ? 바인딩으로 SQL과 값을 분리.


### 기본 코드 구조

```java
import java.sql.*;

public class JdbcExample {
    public static void main(String[] args) {
        // JDBC 변수 선언
        Connection conn = null;
        PreparedStatement ps = null;
        ResultSet rs = null;

        try {
            // 1. Connection 생성
            String url = "jdbc:mysql://localhost:3306/examplesdb";
            conn = DriverManager.getConnection(url, "urstory", "u1234");

            // 2. PreparedStatement 생성
            String sql = "SELECT * FROM user WHERE email = ?";
            ps = conn.prepareStatement(sql);

            // 3. 파라미터 바인딩
            ps.setString(1, "test@example.com");

            // 4. SQL 실행
            rs = ps.executeQuery();

            // 5. 결과 처리
            while(rs.next()) {
                // 데이터 읽기
            }

        } catch(SQLException e) {
            e.printStackTrace();
        } finally {
            // 6. 리소스 해제
            if(rs != null) try { rs.close(); } catch(SQLException e) {}
            if(ps != null) try { ps.close(); } catch(SQLException e) {}
            if(conn != null) try { conn.close(); } catch(SQLException e) {}
        }
    }
}
```

### insert
```java
public void insertUser(String email, String name, String password) {
    String sql = "INSERT INTO user (email, name, password, regdate) " +
                 "VALUES (?, ?, ?, NOW())";

    try (Connection conn = getConnection();
         PreparedStatement ps = conn.prepareStatement(sql)) {

        // 파라미터 바인딩
        ps.setString(1, email);
        ps.setString(2, name);
        ps.setString(3, password);

        // SQL 실행
        int updateCount = ps.executeUpdate();
        System.out.println(updateCount + "개의 행이 입력되었습니다.");

    } catch (SQLException e) {
        e.printStackTrace();
    }
}
```
