# 08/29 회고록


## 자바 API
### 1. Date와 Calendar

### Date
- java.util.Date 클래스는 밀리초 단위의 타임스탬프를 기반으로 날짜와 시간을 표현
- 초창기부터 있던 클래스지만, 많은 메서드들이 비직관적이거나 지역/타임존 처리가 부족해 최근에는 잘 사용하지 않음

### Calendar
- Calendar는 추상 클래스 → 직접 new Calendar()로 생성 불가
- 대신 Calendar.getInstance()를 사용하면, 실제 구현체(GregorianCalendar 등) 가 반환됨
    - 다양한 달력 체계(태양력, 불교력 등)를 지원할 수 있도록 유연하게 설계
    - 사용자는 Calendar라는 공통 인터페이스만 사용하면 되고, 내부 구현체는 JVM/환경에 맞게 제공됨

#### 관련 상수
```
날짜 관련 상수

Calendar.YEAR : 연도
Calendar.MONTH : 월 (0부터 시작 → 0=1월, 11=12월)
Calendar.DATE 또는 Calendar.DAY_OF_MONTH : 월의 일
Calendar.DAY_OF_WEEK : 요일 (일요일=1, 토요일=7)
Calendar.DAY_OF_YEAR : 1년 중 몇 번째 날
Calendar.WEEK_OF_YEAR : 1년 중 몇 번째 주
Calendar.WEEK_OF_MONTH : 한 달 중 몇 번째 주

시간 관련 상수

Calendar.HOUR : 시 (12시간제, 0~11)
Calendar.HOUR_OF_DAY : 시 (24시간제, 0~23)
Calendar.MINUTE : 분 (0~59)
Calendar.SECOND : 초 (0~59)
Calendar.MILLISECOND : 밀리초 (0~999)

AM/PM 관련 상수
Calendar.AM : 오전 (0)
Calendar.PM : 오후 (1)
```

#### 예제
```java
import java.util.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;

public class LegacyDateExample {
    public static void main(String[] args) throws ParseException {
        // Date 클래스
        Date now = new Date();
        System.out.println("현재 시간: " + now);

        // 포맷팅
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        System.out.println("포맷팅: " + sdf.format(now));

        // 파싱 (예외 처리 필요)
        Date parsed = sdf.parse("2025-09-02 16:45:00");
        System.out.println("파싱됨: " + parsed);

        // Calendar 클래스 (추상 → 구현체는 보통 GregorianCalendar)
        Calendar cal = Calendar.getInstance();
        int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH) + 1; // 0부터 시작
        int day = cal.get(Calendar.DAY_OF_MONTH);
        System.out.printf("오늘: %d년 %d월 %d일%n", year, month, day);

        // 날짜 연산
        cal.add(Calendar.DAY_OF_MONTH, 7); // 7일 후
        cal.add(Calendar.MONTH, -1);       // 1달 전

        Date result = cal.getTime();
        System.out.println("계산 결과: " + sdf.format(result));

        // 타임존 적용 (SDF/Calendar 조합)
        sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
        System.out.println("UTC 포맷팅: " + sdf.format(now));
    }
}
```


### 2. LocalDate, LocalTime, LocalDateTime, ZonedDateTime

### LocalDate
- 날짜(년/월/일)만 다룸

### LocalTime

- 시간(시/분/초/나노초)만 다룸
- 알람, 예약 시간 등 **날짜와 무관한 시간** 표현에 적합

### LocalDateTime
- 날짜와 시간을 모두 표현
- LocalDate와 LocalTime을 합친 느낌


### ZonedDateTime

- 시간대(Time Zone) 정보를 포함한 날짜/시간
- 국제 서비스, 서버 간 동기화에서 필수
```java
import java.time.*;
import java.time.format.DateTimeFormatter;

public class LocalDateTimeExample {
    public static void main(String[] args) {
        // 현재 날짜/시간
        LocalDate date = LocalDate.now();
        LocalTime time = LocalTime.now();
        LocalDateTime dateTime = LocalDateTime.now();

        System.out.println("날짜: " + date);        // 2024-04-10
        System.out.println("시간: " + time);        // 15:30:45.123
        System.out.println("날짜시간: " + dateTime); // 2024-04-10T15:30:45.123

        // 특정 날짜/시간 생성
        LocalDate birthday = LocalDate.of(2000, 1, 1);
        LocalTime noon = LocalTime.of(12, 0);
        LocalDateTime appointment = LocalDateTime.of(2024, 12, 25, 18, 30);

        // 날짜 연산
        LocalDate tomorrow = date.plusDays(1);
        LocalDate lastWeek = date.minusWeeks(1);
        LocalDate nextMonth = date.plusMonths(1);

        // 날짜 정보 추출
        int year = date.getYear();
        Month month = date.getMonth();
        int dayOfMonth = date.getDayOfMonth();
        DayOfWeek dayOfWeek = date.getDayOfWeek();

        System.out.printf("%d년 %s %d일 %s%n", 
            year, month, dayOfMonth, dayOfWeek);

        // 포맷팅
        DateTimeFormatter formatter = 
            DateTimeFormatter.ofPattern("yyyy년 MM월 dd일 HH:mm:ss");
        String formatted = dateTime.format(formatter);
        System.out.println("포맷팅: " + formatted);

        // 파싱
        LocalDate parsed = LocalDate.parse("2024-04-10");
        LocalDateTime parsedDT = LocalDateTime.parse("2024-04-10T15:30:45");
    }
}
```

```java
import java.time.*;

public class ZonedDateTimeExample {
    public static void main(String[] args) {
        // 현재 시간대의 날짜시간
        ZonedDateTime now = ZonedDateTime.now();
        System.out.println("현재(서울): " + now);

        // 다른 시간대로 변환
        ZonedDateTime newYork = now.withZoneSameInstant(
            ZoneId.of("America/New_York"));
        System.out.println("뉴욕: " + newYork);

        // 특정 시간대로 생성
        ZonedDateTime paris = ZonedDateTime.of(
            LocalDateTime.now(), 
            ZoneId.of("Europe/Paris"));

        // 사용 가능한 시간대 확인
        Set<String> zoneIds = ZoneId.getAvailableZoneIds();
        zoneIds.stream()
            .filter(z -> z.contains("Seoul"))
            .forEach(System.out::println);
    }
}
```

### 3. Period와 Duration


- Period : 날짜 간격(년/월/일)을 표현
- Duration : 시간 간격(초/나노초)을 표현

```java
import java.time.*;

public class PeriodDurationExample {
    public static void main(String[] args) {
        // Period - 날짜 간격
        LocalDate birth = LocalDate.of(2000, 1, 1);
        LocalDate today = LocalDate.now();

        Period age = Period.between(birth, today);
        System.out.printf("나이: %d년 %d개월 %d일%n", 
            age.getYears(), age.getMonths(), age.getDays());

        // Duration - 시간 간격
        LocalTime start = LocalTime.of(9, 0);
        LocalTime end = LocalTime.of(17, 30);

        Duration workTime = Duration.between(start, end);
        System.out.println("근무 시간: " + workTime.toHours() + "시간 " + 
            (workTime.toMinutes() % 60) + "분");

        // Instant - 타임스탬프
        Instant instant = Instant.now();
        System.out.println("타임스탬프: " + instant);
        System.out.println("에포크 초: " + instant.getEpochSecond());
    }
}
```





## Comparable & Comparator

### 1. Comparable
- Comparable<T> 인터페이스는 객체 자체가 비교 기준을 내장하도록 하는 방식
- compareTo() 메소드를 반드시 오버라이드해야 함
- 객체의 자연 순서를 정의
    - String은 알파벳 순서, Integer는 숫자 크기 순서 등

### 예제 코드
```java
import java.util.*;

public class Person implements Comparable<Person> {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int compareTo(Person other) {
        return this.age - other.age; // 나이 오름차순 정렬
    }

    @Override
    public String toString() {
        return name + ": " + age;
    }

    public static void main(String[] args) {
        List<Person> people = new ArrayList<>();
        people.add(new Person("Alice", 32));
        people.add(new Person("Bob", 24));
        people.add(new Person("Charlie", 28));

        Collections.sort(people); // Person에 정의된 compareTo 사용
        System.out.println(people);
    }
}
``` 
### 결과
```
[Bob: 24, Charlie: 28, Alice: 32]
```


### 2. Comparator
- Comparator<T> 인터페이스는 객체 외부에서 비교 기준을 정의하는 방식
- compare(T o1, T o2) 메소드를 구현해야 함
- 여러 기준(이름, 나이, 점수 등)으로 유연하게 정렬 가능
- Comparator는 필요할 때마다 외부에서 정렬 기준을 정의할 수 있어 유연함.
    - 일반 클래스 : 재사용성이 높음
    - 익명 클래스 : 한 번만 쓰는 기준일 때
    - 람다 : 코드가 간결하고 가독성이 좋음

#### 일반 클래스
```java
import java.util.*;

class NameComparator implements Comparator<Person> {
    @Override
    public int compare(Person p1, Person p2) {
        return p1.getName().compareTo(p2.getName()); // 이름 기준 정렬
    }
}

class Person {
    private String name;
    private int age;

    public Person(String name, int age) { this.name = name; this.age = age; }
    public String getName() { return name; }
    @Override
    public String toString() { return name + ": " + age; }

    public static void main(String[] args) {
        List<Person> people = Arrays.asList(
            new Person("Alice", 32),
            new Person("Bob", 24),
            new Person("Charlie", 28)
        );

        Collections.sort(people, new NameComparator());
        System.out.println(people);
    }
}
```
#### 익명 클래스
```java
Collections.sort(people, new Comparator<Person>() {
    @Override
    public int compare(Person p1, Person p2) {
        return Integer.compare(p1.age, p2.age); // 나이 기준 정렬
    }
});
```
#### 람다 표현식
```java
Collections.sort(people, (p1, p2) -> p1.getName().compareTo(p2.getName()));
```

결과
```
[Alice: 32, Bob: 24, Charlie: 28]
```