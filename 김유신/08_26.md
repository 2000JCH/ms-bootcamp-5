# 08_26 회고록

<br>

## 추상 클래스(Abstract Class)

### 추상화
- 구체적인 사물이나 개념에서 **공통적인 속성과 행위만 뽑아내는 과정**
- 객체지향에서 추상화는 “구현 세부사항은 감추고, 공통 성질과 동작만 드러내는 것”을 의미

### 추상 클래스 특징
- `abstract` 키워드 사용, **인스턴스 생성 불가**
- 추상 메소드 포함 가능
- **템플릿 역할**: 자식 클래스에게 일정한 구조를 강제하고, 일부 공통 기능은 직접 제공
- 추상 클래스 자체도 **타입으로서의 역할**을 함

### 일반 클래스 상속 vs 추상 클래스 상속
- **일반 클래스**
  - 부모 클래스가 모든 메소드를 구현
  - 자식 클래스는 필요 시 오버라이딩 + 추가 기능 확장
  - 완성된 기능을 **재사용/확장**하기에 유리

- **추상 클래스**
  - 부모 클래스가 일부 구현 + 일부는 추상화
  - 자식 클래스는 반드시 추상 메소드를 구현해야 함
  - **설계 지침 + 공통 코드** 제공 → 자식에게 **명확한 틀**을 강제

### 사용하기 좋은 경우
- 공통 속성과 동작을 공유하되, 세부 구현은 달라야 할 때
- 예: `Shape(도형)` → `getArea()`, `getPerimeter()`는 도형별로 구현 방식이 다름
- **기본 동작을 제공하면서도 필수 구현을 강제하고 싶을 때**


## 인터페이스(Interface)

### 개념
- 인터페이스는 구현해야 할 **기능의 목록** 을 정의하는 틀
- 세부 구현은 전적으로 구현 클래스에게 위임

### 특징
- 모든 메소드는 원칙적으로 `public abstract` (Java 8 이전)
- **다중 상속 허용** (클래스는 단일 상속만 가능, 인터페이스는 여러 개 구현 가능)
- 구현체는 기본적으로 인터페이스에 선언된 추상 메소드를 직접 구현하기에 서로간의 **결합도가 낮음**.
    - 결합도 : 각 모듈간 연결된 정도
    - 객체지향 프로그래밍시 결합도는 낮게 구현하는것이 권장됨
    - SOLID 원칙 중 DIP (의존 역전 원칙), ISP (인터페이스 분리 원칙) ,OCP (개방-폐쇄 원칙)등을 지키기 위해 인터페이스가 주로 활용됨


### 인터페이스의 `default`와 `static` 메서드 (Java 8+)

### 1. default 메서드
- 인터페이스에 **구현이 있는 메서드**를 정의할 수 있음
- 장점:
  - 기존 인터페이스에 메소드 추가 시, 모든 구현체를 수정하지 않아도 됨  
  - 필요하다면 구현 클래스에서 오버라이딩 가능
- 기존 코드와의 **호환성**을 유지하면서, 인터페이스에 기능을 확장할 수 있는 방법 제공
- 사용 예: `Collection` 인터페이스의 `forEach()`

### 2. static 메서드
- 인터페이스에 **클래스 메서드처럼 호출 가능한 메서드**를 정의 가능
- 구현체와 무관하게 **인터페이스 자체의 유틸리티 기능**을 제공할 수 있음
- 사용 예: `Comparator.comparing()`


### 추상 클래스 vs 인터페이스
- **공통점**
  - 직접 인스턴스 생성 불가
  - 다형성 제공
  - 구현을 강제 → **형식과 규격을 명확히 제공**

- **차이점**
  - 추상 클래스: **is-a 관계**, 속성 일부 기능 구현 포함 가능  
    - 부모의 기본 동작 + 틀 제공 
    - 유사한 객체군을 묶어 공통 속성과 기능을 공유해야 하지만, 각 객체군별 세부 구현이 다를 때
  - 인터페이스: **has-a 관계**, 오직 기능(행위) 정의 중심  
    - 틀만 제공
    - 관련 없는 객체여도 동일한 기능을 할 경우 사용


## Object 클래스
- 자바에서 **모든 클래스의 최상위 클래스**  
- 명시적으로 상속하지 않으면 자동으로 `extends Object`가 적용됨  
- 따라서 모든 객체는 최소한 `Object`의 메소드들을 기본적으로 가짐  


### 주요 메소드

### 1. `toString()`
- 기본 구현: `"클래스명@해시코드(16진수)"` 반환
- 주로 객체의 정보를 문자열로 보기 위해 오버라이딩
- `System.out.println(obj)` 호출 시 내부적으로 `obj.toString()`이 실행
- String의 경우 오버라이딩을 통해 실제 값을 반환하게 변경되어있음
- **왜 추상 메소드가 아닐까?**
  - 만약 추상 메소드였다면, 모든 클래스에서 반드시 `toString()`을 구현해야 했음 → 불필요한 코드 증가  
  - 그래서 기본 구현(클래스명@주소)을 두고, 필요에 따라 오버라이딩 하는 구조가 합리적
  - ex) String.toString(); -> 실제 값 반환

### 2. `equals(Object obj)`
- 기본 구현: `==` (참조 비교)와 동일  
- String의 경우 객체의 **실제 값**을 비교하도록 오버라이딩 되어있음


### 3. `hashCode()`
- 객체의 해시 값 반환 (정수)  
- `equals()`와 함께 오버라이딩해야 함  
- **규칙**
  1. `equals()`가 true라면 `hashCode()`도 같아야 함  
  2. `hashCode()`가 같다고 해서 `equals()`가 true일 필요는 없음  
- HashMap, HashSet 등 해시 기반 컬렉션에서 올바른 동작을 위해 두 메소드 동시 재정의 필수  


### 4. `getClass()`
- 객체의 실제 클래스 타입 정보를 반환  
- 리플렉션(Reflection) 등에 활용  

### 5. `clone()`
- 객체를 복제하여 새로운 객체 생성  
- 사용하려면 `Cloneable` 인터페이스 구현 필요  