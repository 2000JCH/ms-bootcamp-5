# 09/11 회고록


## 조인 (JOIN)

- 서로 다른(또는 같은) 테이블의 행을 키로 나란히 붙여 한 줄처럼 조회.

### 종류
- INNER JOIN: 양쪽 조건을 만족하는 행만 (교집합).
- LEFT JOIN: 왼쪽은 모두 남기고, 오른쪽 매칭 없으면 NULL.
- RIGHT JOIN: 오른쪽은 모두 남기고, 왼쪽 매칭 없으면 NULL.
- SELF JOIN: 같은 테이블을 역할(alias) 로 나눠 서로 비교.
- CROSS JOIN: 조건 없이 곱집합.
### ON vs WHERE 
- ON = 붙이는 기준
- WHERE = 최종 필터
- ON에는 조인에 대한 조건만, WHERE은 쿼리 전반적인 조건


```sql
-- INNER: 사원과 부서명 나란히
SELECT e.ename, d.dname
FROM emp e
JOIN dept d ON d.deptno = e.deptno;

-- LEFT: 부서 매칭이 없어도 사원은 보존
SELECT e.ename, e.deptno, d.dname
FROM emp e
LEFT JOIN dept d ON d.deptno = e.deptno;

-- SELF: 상사보다 급여가 높은 사원
SELECT e.empno, e.ename, e.sal, m.ename AS mgr_name, m.sal AS mgr_sal
FROM emp e
JOIN emp m ON m.empno = e.mgr
WHERE e.sal > m.sal;

-- CROSS: 모든 부서 × 직무 조합
SELECT d.dname, j.job
FROM dept d
CROSS JOIN (SELECT DISTINCT job FROM emp) j;
```

## 서브쿼리 (Subquery)
- 스칼라(1행 1열): 등호/부등호로 직접 비교 가능.
- 다중행: 여러 행 반환 → IN / EXISTS / ANY / ALL 같은 집합 비교 필요.
- 상관 서브쿼리: 서브쿼리가 바깥 행의 값을 참조(행마다 기준이 달라질 때 유용).


```sql
-- 스칼라: 전체 평균보다 급여가 낮은 사원
SELECT * 
FROM emp e
WHERE e.sal < (SELECT AVG(sal) FROM emp);

-- 다중행 IN: 'SALES' 부서 사원
SELECT *
FROM emp
WHERE deptno IN (SELECT deptno FROM dept WHERE dname = 'SALES');

-- EXISTS: 부하가 한 명이라도 있는 매니저
SELECT *
FROM emp e
WHERE EXISTS (SELECT 1 FROM emp s WHERE s.mgr = e.empno);

-- ANY/ALL: 30번 부서의 최고 연봉자
SELECT *
FROM emp
WHERE sal > ALL (SELECT sal FROM emp WHERE deptno = 30);

-- 상관 스칼라: 상사 급여를 칼럼으로 붙이기
SELECT e.empno, e.ename, e.sal,
       (SELECT m.sal FROM emp m WHERE m.empno = e.mgr) AS mgr_sal
FROM emp e;
```

## 윈도 함수
- FUCNTION() OVER(PARTITION BY … [ORDER BY …])로 행 수는 그대로, 파티션(관련 행 묶음)을 보며 계산 칼럼을 붙임.


- SELECT/ORDER BY에서만 사용. 
- 같은 레벨의 WHERE/GROUP BY/HAVING/ON에는 둘 수 없음.

종류
- ROW_NUMBER() = 동률 무시
- RANK() = 동률 후 순위 건너뜀(1,2,2,4…)
- DENSE_RANK() = 동률 후 건너뜀 없음(1,2,2,3…)

```sql
예시

-- 부서 평균 급여를 각 행에 붙이기
SELECT empno, ename, deptno, sal,
       AVG(sal) OVER (PARTITION BY deptno) AS dept_avg
FROM emp;

-- 부서별 급여 상위 3위 이내(동률 포함)
SELECT *
FROM (
  SELECT e.*,
         DENSE_RANK() OVER (PARTITION BY deptno ORDER BY sal DESC) AS rnk
  FROM emp e
) x
WHERE x.deptno IS NOT NULL AND x.rnk <= 3
ORDER BY x.deptno, x.sal DESC;
```

## 튜플 비교
- 여러 컬럼을 한 덩어리로 정확 매칭.
```sql

SELECT deptno, empno, ename, sal
FROM emp
WHERE (deptno, sal) IN (
  SELECT deptno, MAX(sal)
  FROM emp
  GROUP BY deptno
);
```
##  HAVING vs WHERE 
- WHERE: 행 필터(그룹 만들기 전).
- HAVING: 그룹 필터(집계 후).

- 논리 순서: FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY.
- 위의 순서상 SELECT에서 만든 별칭은 WHERE에서 못 씀.



## 연습 - 부서별 상위 월급 상위 3명 순서대로 출력
```sql
--- 서브쿼리 
SELECT e.empno, e.ename, e.sal,
       (SELECT COUNT(DISTINCT e2.sal)
          FROM emp e2
         WHERE e2.deptno = e.deptno AND e2.sal > e.sal) + 1 AS rnk
FROM emp e
WHERE e.deptno IS NOT NULL
HAVING rnk <= 3;  

-- 윈도함수
SELECT *
FROM (
  SELECT *,
         rank() OVER (PARTITION BY deptno ORDER BY  sal DESC) AS rnk
  FROM emp
) x
WHERE x.rnk <= 3 and deptno is not null;
```
