# 8-25

### 상속

- 부모 클래스의  필드와 메소드를 자식 클래스가 물려받음
- 코드의 재사용성과 확장성 향상

**예시 : 서블릿 (Servlet)**

- 자바를 사용하여 웹을 만들기 위해 필요한 기술
- 클라이언트가 어떠한 요청을 하면 그에 대한 결과를 다시 전송해야 하는데, 이러한 역할을 하는 자바 프로그램
- Ex: 사용자가 로그인을 하려고 Id, Password를 입력 후 로그인 버튼을 누르면, 그때 서버는 클라이언트의 Id, Password를 확인하고, 다음 페이지를 띄어주어야 하는데 이러한 역할을 수행하는 것이 바로 서블릿(Servlet)이다.
- 참고사이트: [https://mangkyu.tistory.com/14](https://mangkyu.tistory.com/14)

**참고: JSP**

- JSP는 서블릿 기반으로 만들어진 동적 웹 페이지 기술
- 내부적으로 JSP → 서블릿으로 변환되어 실행

---

### 다향성

- 하나의 이름이 여러 형태로 동작할 수 있는 성질
- 즉, 하나의 메소드나 객체 이름이 상황에 따라 다르게 행동하는 것
- Ex: 메소드 오버로딩, 메소드 오버라이딩

---

### 메소드 오버라이드

- 오버라이딩 = 메소드 오버라이드
- 부모 클래스의 메소드를 자식 클래스에서 재정의
- 메소드 이름, 매개변수, 반환 타입이 동일해야 함
- @Override 어노테이션 사용 권장

```java
class Animal {
    public void makeSound() {
        System.out.println("동물이 소리를 냅니다.");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("멍멍!");
    }
}

public class Test {
    public static void main(String[] args) {
        Animal a = new Dog();
        a.makeSound(); // 멍멍!
    }
}
```

---

### 필드와 메소드의 동작 차이

```java
import javax.swing.*;

class Parent {
    int i = 10;
    public int getI(){
        return i;
    }
}

class Child extends Parent{
    int i = 20; //(부모가 가진것을 자식이 똑같이 다시 정의하는 것 --> 오버라이딩 (오버라이딩은 메소드에서만 적용)
    public int getI(){
        return i;
    }
}

public class Exam{
    public static void main(String[] args) {
        Parent p = new Parent();
        Parent c = new Child();

        System.out.println(p.i); // 10 → Parent 객체
        System.out.println(c.getI()); // 20 → Child 객체
    }
}

/*
Parent a = new Child() // 가능

Child b = new Parent(); //불가능
*/
```

1. 부모는 자식을 가리킬 수 있다.
2. 자식은 부모를 가리킬 수 없다.
3. 필드는 타입을 따른다.
4. 메소드 오버라이드 되면 무조건 자식의 것이 사용

---

### super()

- 부모 클래스의 기본 생성자(인자 없는 생성자)를 호출하게 된다. (생략됐을 수도)
- 자식 클래스 생성자의 첫 줄에 자동으로 붙는다.

---

**필드가 모두 Private 하다면 어떻게 사용할까?**

```java
package day06;

public class Person {
    private int age;
    private String name;

		// Getter and Setter 메소드
    public void SetAge(int age){
        this.age = age;
    }

    public String getName(){
        return name;
    }
}
```

웬만하면 필드는 Private 선언하는 것이 일반적

- Private 한 객체를 사용하려면 직접 접근하게 하기보다는 메서드를 이용해야 함
- Getter and Setter 메소드를 사용한다 (ALT + INSERT)

---

### 다운캐스팅

```java
class Animal {
    public void eat() {
        System.out.println("동물이 먹습니다.");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("멍멍!");
    }
}

public class TestCasting {
    public static void main(String[] args) {
        Animal a = new Dog(); // 업캐스팅: 자식 → 부모
        a.eat();              // 동물이 먹습니다.

        // a.bark(); // X 부모 타입으로는 자식 메소드 호출 불가

        // 다운캐스팅: 부모 → 자식
        Dog d = (Dog) a;
        d.bark();             // 멍멍!
    }
}
/*
동물이 먹습니다.
멍멍!
*/
```

- 자식 클래스에만 있는 고유한 메소드, 필드를 사용하기 위해