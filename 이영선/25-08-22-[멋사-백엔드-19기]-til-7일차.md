\- 상속의 개념::extends, object, 단일 상속, 생성자는 상속되지 않는다.  
\- 부모 클래스와 자식 클래스의 생성자 호출 관련  
\- 부모 클래스형의 자식 클래스 생성자 인스턴스 :: super, this  
\- 메소드 오버라이딩::override  
\- final 키워드::final 클래스는 상속 불가능, 메소드는 overriding 불가능, 변수는 값 변경 불가  
\- 다형성::부모 타입 면수로 자식 객체를 참조할 수 있음.  
\- 타입 변환::upCasting, downCasting  
\- 접근 제한자::이건 오늘 안한거 같아요~

1\. 상속

부모가 가진 속성과 기능을 그대로 물려 받는것.

\- extends

```
// 부모 클래스 (Animal)
class Animal {
    String name;

    void eat() {
        System.out.println(name + "가(이) 음식을 먹습니다.");
    }
}

// 자식 클래스 (Dog) → Animal을 상속
class Dog extends Animal {
    void bark() {
        System.out.println(name + "가(이) 멍멍 짖습니다.");
    }
}

// 실행 클래스
public class InheritanceExample {
    public static void main(String[] args) {
        Dog myDog = new Dog();
        myDog.name = "바둑이";   // Animal 클래스에서 상속받은 필드 사용
        myDog.eat();            // Animal 클래스에서 상속받은 메소드 호출
        myDog.bark();           // Dog 클래스의 메소드 호출
    }
}
```

\- **단일 상속만 지원** → 클래스는 하나의 부모 클래스만 가질 수 있음.

```
class A {}
class B extends A {}  // 가능
class C extends A, B {}  // ❌ 불가능
```

\- 생성자는 상속되지 않는다.

자식 객체 생성 시 부모 생성자가 먼저 실행되고, 그 다음에 자식 생성자가 실행됨.

2\. 부모 클래스와 자식 클래스의 생성자 호출 관련

\- 기본 생성자(default)

```
class Parent {
    Parent() {
        System.out.println("부모 생성자 호출");
    }
}

class Child extends Parent {
    Child() {
        System.out.println("자식 생성자 호출");
    }
}

public class ConstructorExample1 {
    public static void main(String[] args) {
        Child c = new Child();
    }
}
```

```
부모 생성자 호출
자식 생성자 호출
```

\- 매개변수가 있는 생성자

```
class Parent {
    Parent(String name) {
        System.out.println("부모 생성자: " + name);
    }
}

class Child extends Parent {
    Child(String name) {
        super(name); // 반드시 부모 생성자를 명시적으로 호출해야 함
        System.out.println("자식 생성자: " + name);
    }
}

public class ConstructorExample3 {
    public static void main(String[] args) {
        Child c = new Child("홍길동");
    }
}
```

3.  this와 super를 사용한 생성자 호

```
class Parent {
    Parent() {
        System.out.println("부모 기본 생성자 호출");
    }

    Parent(String msg) {
        System.out.println("부모 생성자: " + msg);
    }
}

class Child extends Parent {
    Child() {
        this("기본 자식"); // 같은 클래스의 다른 생성자 호출
        System.out.println("자식 기본 생성자 호출");
    }

    Child(String name) {
        super("부모에게 전달됨"); // 부모 생성자 호출
        System.out.println("자식 생성자: " + name);
    }
}

public class ThisSuperExample {
    public static void main(String[] args) {
        System.out.println("=== Child() 호출 ===");
        Child c1 = new Child();

        System.out.println("\n=== Child(\"홍길동\") 호출 ===");
        Child c2 = new Child("홍길동");
    }
}
```

```
=== Child() 호출 ===
부모 생성자: 부모에게 전달됨
자식 생성자: 기본 자식
자식 기본 생성자 호출

=== Child("홍길동") 호출 ===
부모 생성자: 부모에게 전달됨
자식 생성자: 홍길동
```

\- 오버라이딩 : 부모가 가진것을 자식이 다시 정의 하는 것.

\- 부모(조상)은 자식(자손)을 가리킬 수 있다.(반대는 안됨)

\-  필드는 타입을 따른다.

\-  메소드는 오버라이드 되면 무조건 자식의 것을 사용

```
//형변환시에는 인스턴스가 중요!!
if(pp instanceof Child1) {
    Child1 cc = (Child1) pp; //이것을 실행하면. 어떤일이?
}
```

```
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE) 
public @interface  Override{
```

4\. 메소드 오버라이딩::override

```
// Animal.java
class Animal {
    public void makeSound() {
        System.out.println("동물이 소리를 냅니다.");
    }
}

// Cat.java
class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("야옹!");
    }
}

// Main.java
public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();
        Dog myDog = new Dog();
        Cat myCat = new Cat();

        myAnimal.makeSound(); // 출력: 동물이 소리를 냅니다.
        myDog.makeSound();    // 출력: 멍멍!
        myCat.makeSound();    // 출력: 야옹!
    }
}
```
