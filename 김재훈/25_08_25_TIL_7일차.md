# 상속(Inheritance)

## 상속이란?

- 일반화와 확장의 개념을 합친 것으로, 객체 지향 프로그래밍의 핵심 요소 중 하나이다.
- 이름 그대로 부모 클래스의 필드와 메서드를 자식 클래스가 그대로 물려받는 것이다.
- **is-a 관계** 또는 **kind-of 관계**로 표현한다.
- 코드의 **재사용성**과 **확장성**을 향상시킨다.
- 자바는 다중 상속을 지원하지 않는다. 따라서 `extends` 대상은 하나만 선택할 수 있다.
    - 예를 들어서 `Pen()` 클래스와 `Device()` 클래스를 상속 받은 `ApplePencil()` 클래스가 있고, `Pen()` 클래스와 `Device()` 클래스 모두 `write()`라는 메서드가 있다고 가정하자.
    - 이 상황에서 `ApplePencil()`이 `write()` 메서드를 호출할 때, 어떤 부모의 메서드를 호출해야 할지 애매한 문제가 발생하는데, 이것을 다이아몬드 문제라 한다.
    - 또한, 다중 상속을 사용하게 되면 클래스 계층 구조가 매우 복잡해질 우려가 있어 자바는 다중 상속을 지원하지 않는다.
    - 인터페이스 구현(`implements`)의 경우는 다중 구현이 가능하다.
- 클래스를 `final`로 선언할 경우 확장될 수 없다. 따라서 다른 클래스가 해당 클래스를 상속받을 수 없다.

### 용어 정리

- **부모 클래스 (슈퍼 클래스)** : 상속을 통해 자신의 필드와 메서드를 다른 클래스에 제공하는 클래스
- **자식 클래스 (서브 클래스)** : 부모 클래스로부터 필드와 메서드를 상속받는 클래스

### super 와 super()

- **super** : 자식에서 부모의 필드나 메서드에 접근하려고 할 때 해당 키워드로 부모를 참조할 수 있다.
    - 부모와 자식의 필드명이 같거나 메서드가 오버라이딩 되어 있으면, 자식에서 부모의 필드나 메서드를 호출할 수 없는데, 이때 `super` 키워드를 사용하면 부모를 참조할 수 있다.
    - `this` 키워드를 통해 본인 타입을 참조할 수 있고, `super` 키워드를 통해 부모 타입을 참조할 수 있다.
- **super()** : 부모 클래스의 생성자를 호출한다.
    - 상속 관계를 사용한 자식 클래스의 생성자는 첫 줄에 `super()` 또는 `this()`를 호출해야 한다.
    - 부모 클래스의 생성자가 기본 생성자(파라미터가 없는 생성자)인 경우 `super()`를 생략할 수 있다.
    - 명시하지 않을 경우 기본 생성자를 호출하는 `super()`를 자바에서 자동으로 만들어준다.
    - `this()`를 사용하더라도 언젠가는 자식의 생성자 안에서 `super()`를 호출해야 한다.
    - 상속 관계의 생성자 호출은 부모에서 자식 순서로 실행된다. 따라서 부모의 데이터를 먼저 초기화하고, 그 다음에 자식의 데이터를 초기화한다.

### 상속과 메모리 구조

- 예시를 위해 `Device` 클래스를 상속받은 `Phone` 클래스가 있다고 가정하자. 추가로 `Device` 클래스에는 `turnOn()` 메서드가 있고, `Phone` 클래스에는 `call()` 메서드가 있다고 가정하자.
- `Phone phone = new Phone()`을 호출하면 메모리에는 `Phone`과 상속 관계에 있는 `Device` 클래스까지 함께 포함해서 인스턴스를 생성한다.
- 즉, 인스턴스의 참조값은 하나이지만 두 가지 클래스 정보가 공존하는 것이다.
- `phone.call()`을 호출하면 참조값을 확인해서 메서드를 호출하는데, 상속 관계의 경우 내부에 부모(`Device`)와 자식(`Phone`)이 모두 존재한다.
- `call()`을 `Device`를 통해 찾을지, `Phone`을 통해 찾을지 선택해야 하는데, 이때는 **호출하는 변수의 타입(클래스)**을 기준으로 선택한다.
- `phone`의 타입이 `Phone`이므로 인스턴스 내부에 같은 타입인 `Phone`을 통해 `call()`을 호출한다.
- `phone.turnOn()`과 같이 상속 관계에서 자식에게 해당 기능이 없으면 부모로 올라가서 해당 기능을 찾는다.
- 만약 부모에서도 해당 기능을 찾지 못한다면 더 부모로 올라가면서 찾고, 계속 찾아도 없다면 컴파일 오류가 발생한다.

## 상속 선언 예시

- 부모 클래스
    
    ```java
    public class Vehicle {
    	protected String brand;
    	protected String model;
    	protected int year;
    	
    	public Vehicle(String brand, String model, int year) {
    		this.brand = brand;
    		this.model = model;
    		this.year = year;
    	}
    	
    	public void start() {
    		System.out.println(brand + " " + model + "의 시동을 겁니다.");
    	}
    	
    	public void stop() {
    		System.out.println(brand + " " + model + "의 시동을 끕니다.");
    	}
    	
    	public void displayInfo() {
    		System.out.println("브랜드: " + brand);
    		System.out.println("모델: " + model);
    		System.out.println("연식: " + year);
    	}
    }
    ```
    
- 자식 클래스1
    
    ```java
    public class Car extends Vehicle {
    	private int numberOfDoors;
    	
    	public Car(String brand, String model, int year, int numberOfDoors) {
    		super(brand, model, year); // 부모 생성자 호출
    		this.numberOfDoors = numberOfDoors;
    	}
    	
    	// Car만의 고유 메서드
    	public void openTrunk() {
    		System.out.println("트렁크를 엽니다.");
    	}
    	
    	@Override
    	public void displayInfo() {
    		super.displayInfo(); // 부모 메서드 호출
    		System.out.prinltn("문 개수: " + numberOfDoors);
    	}
    }
    ```
    
- 자식 클래스2
    
    ```java
    public class Motorcycle extends Vehicle {
    	private String type;
    	
    	public Car(String brand, String model, int year, String type) {
    		super(brand, model, year);
    		this.type = type;
    	}
    	
    	// MotorCycle만의 고유 메서드
    	public void wheelie() {
    		System.out.println("휠리를 합니다!");
    	}
    	
    	@Override
    	public void displayInfo() {
    		super.displayInfo(); // 부모 메서드 호출
    		System.out.prinltn("오토바이 타입: " + type);
    	}
    }
    ```
    

## 상속 활용 예제

```java
public class VehicleMain {
	public static void main(String[] args) {
		Car car = new Car("현대", "소나타", 2023, 4);
		Motorcycle bike = new Motorcycle("할리데이비슨", "스포츠스터", 2022", "크루저");
		
		System.out.println("=== 자동차 정보 ===");
		car.displayInfo();
		car.start();
		car.oepnTrunk();
		car.stop();
		
		System.out.println("\n=== 오토바이 정보 ===");
		bike.displayInfo();
		bike.start();
		bike.wheelie();
		bike.stop();
	}
}

/*
실행 결과
=== 자동차 정보 ===
브랜드: 현대
모델: 소나타
연식: 2023
문 개수: 4
현대 소나타의 시동을 겁니다.
트렁크를 엽니다.
현대 소나타의 시동을 끕니다.

=== 오토바이 정보
브랜드: 할리데이비슨
모델: 스포츠스터
연식: 2022
오토바이 타입: 크루저
할리데이비슨 스포츠스터의 시동을 겁니다.
휠리를 합니다!
할리데이비슨 스포츠스터의 시동을 끕니다.
*/
```

---

# 메서드 오버라이딩(Method Overriding)

## 오버라이딩이란?

- 부모 클래스에서 상속 받은 메서드를 자식 클래스에서 **재정의** 하는 것이다.
- 메서드 이름, 매개변수, 반환 타입이 동일해야 한다.
- `@Override` 애노테이션 사용을 권장한다.
    - 컴파일러가 이 애노테이션을 보고 메서드가 정확히 오버라이드 되었는지 확인한다.
    - 만약 부모 클래스에 해당 메서드가 없는 것과 같이 오버라이딩 조건을 만족시키지 않는 경우 컴파일 에러가 발생한다.
    - 따라서 실수로 오버라이딩 못하는 경우를 방지해준다.
    - 필수 기능은 아니지만 코드의 명확성을 위해 붙여주는 것이 좋다.
- 인스턴스를 통해 메서드를 호출할 때 오버라이딩 된 메서드가 우선권을 가진다.

> **참고 : 오버로딩(Overloading)과 오버라이딩(Overriding)**
> 
> - **메서드 오버로딩**
>     - 메서드 이름이 같고 매개변수(파라미터)가 다른 메서드를 여러 개 정의하는 것이다.
>     - 번역하면 과적, 과하게 물건을 담았다는 뜻이므로 같은 이름의 메서드를 여러 개 정의했다고 보면 된다.
> - **메서드 오버라이딩**
>     - 하위 클래스에서 상위 클래스의 메서드를 재정의하는 과정을 의미한다. 따라서 상속 관계에서 사용한다.
>     - 우리말로 번역하면 무언가를 다시 정의한다고 해서 재정의라 한다.
>     - 상속 관계에서는 기존 기능을 다시 정의한다고 이해하면 된다.

### 오버라이딩 규칙

- **메서드 이름**
    - 메서드 이름이 같아야 한다.
- **메서드 매개변수(파라미터)**
    - 매개변수(파라미터) 타입, 순서, 개수가 같아야 한다.
- **반환 타입**
    - 반환 타입이 같아야 한다. 단, 반환 타입이 하위 클래스 타입일 수 있다.
- **접근 제어자**
    - 상위 클래스보다 더 제한적이어서는 안된다.
    - 예를 들어 상위 클래스가 `protected`로 선언되어 있다면, 하위 클래스는 `public` 또는 `protected`로만 오버라이드가 가능하다.
- **예외**
    - 상위 클래스의 메서드보다 더 많은 체크 예외를 `throw`로 선언할 수 없다.
    - 하지만 더 적거나 같은 수의 예외, 또는 하위 타입의 예외는 선언할 수 있다.
- `static`, `final`, `private` 키워드가 붙은 메서드는 오버라이딩 될 수 없다.
    - `static`은 클래스 레벨에서 작동하므로 인스턴스 레벨에서 사용하는 오버라이딩이 의미가 없다.
    - `final` 메서드는 재정의를 금지한다.
    - `private` 메서드는 해당 클래스에서만 접근 가능하기 때문에 하위 클래스에서 보이지 않아 오버라이딩 할 수 없다.
- **생성자 오버라이딩**
    - 생성자는 오버라이딩 할 수 없다.

### 예제 코드

```java
public class Animal {
	public void makeSound() {
		System.out.println("동물이 소리를 냅니다.");
	}
	
	public void move() {
		System.out.println("동물이 움직입니다.");
	}
}

public class Dog extends Animal {
	@Override
	public void makeSound() {
		System.out.println("멍멍");
	}
	
	@Override
	public void move() {
		System.out.println("강아지가 네 발로 뛰어다닙니다.");
	}
	
	// Dog만의 고유 메서드
	public void wagTail() {
		System.out.println("꼬리를 흔듭니다.");
	}
}

public class Cat extends Animal {
	@Override
	public void makeSound() {
		System.out.println("야옹");
	}
	
	@Override
	public void move() {
		System.out.println("고양이가 살금살금 걷습니다.");
	}
	
	// Cat만의 고유 메서드
	public void scratch() {
		System.out.println("할퀴기!");
	}
}
```
