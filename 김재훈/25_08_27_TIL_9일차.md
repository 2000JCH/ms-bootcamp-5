# final 키워드와 열거형

## final 키워드

- 이름 그대로 끝! 이라는 뜻이다.
- 변수에 `final` 키워드가 붙으면 더 이상 값을 변경할 수 없다.
- `final`은 클래스, 메서드를 포함한 여러 곳에 붙을 수 있다.
- 지역 변수에 `final`을 설정할 경우 최초 한 번만 할당할 수 있다. 이후 변수의 값을 변경하려면 컴파일 오류가 발생한다.
    
    ```java
    // final 지역변수
    final int data = 10;
    // data = 20; // 컴파일 오류
    ```
    
- 매개변수에 `final`이 붙으면 메서드 내부에서 매개변수의 값을 변경할 수 없다. 따라서 메서드 호출 시점에 사용된 값이 끝까지 사용된다.
    
    ```java
    // final 매개변수
    void method(final int parameter) {
    	// parameter = 20; // 컴파일 오류
    }
    ```
    
- 필드에 `final`을 사용할 경우 해당 필드는 생성자를 통해 한 번만 초기화 될 수 있다.
    
    ```java
    // final 필드 - 생성자 초기화
    public class ConstructInit {
    	final int value;
    	
    	public ConstructInit(int value) {
    		this.value = value;
    	}
    }
    ```
    
- `final` 필드를 필드에서 초기화하면 이미 값이 설정되었기 때문에 생성자를 통해서도 초기화 할 수 없다.
    
    ```java
    // final 필드 - 필드 초기화
    public class FieldInit {
    	static final int CONST_VALUE = 10;
    	final int value = 10;
    }
    ```
    
- `final`을 참조형 변수에 사용하면 참조 대상의 참조값은 다른 값으로 변경하지 못한다. 하지만 참조하는 대상의 필드값은 `final`이 아니라면 변경이 가능하다.
    
    ```java
    class Data {
    	int value;
    }
    
    public class FinalRefMain {
    	public static void main(String[] args) {
    		final Data data = new Data();
    		// data = new Data(); // data가 final이므로 변경 불가, 컴파일 오류
    		
    		// 참조 대상의 값은 final이 아니라면 변경 가능
    		data.value = 10;
    		data.value = 20;
    	}
    }
    ```
    

## final 키워드 예제

```java
// final 변수 - 값 변경 불가
public class FinalExample {
	private final int MAX_SIZE = 100; // 선언과 동시에 초기화
	private final String name;
	private final List<String> items; // 참조는 불변, 내용은 변경 가능
	
	public FinalExample(String name) {
		this.name = name; // 생성자에서 초기화
		items = new ArrayList<>();
	}
	
	// final 메서드 - 오버라이딩 불가
	public final void display() {
		System.out.println("Name: " + name);
	}
	
	public void addItems(String item) {
		items.add(item); // 내용 변경 가능
		// items = new ArrayList<>(); // 참조 변경 불가능
	}
}

// final 클래스 - 상속 불가
public final class ImmutableClass {
	// String, Integer 등이 final 클래스의 예시
}

// 컴파일 오류: final 클래스는 상속 불가
// public class ChildClass extends ImmutableClass {}
```

## 열거형(Enum)

- 타입 안전성을 제공하고, 코드의 가독성을 높이며, 예상 가능한 값의 집합을 표현하는데 사용된다.
- `java.lang.Enum`을 자동(강제)으로 상속 받기 때문에 다른 클래스를 상속 받을 수 없다. 하지만 인터페이스는 구현할 수 있다.
- 정의할 때 `class` 대신 `enum`을 사용하고, 원하는 상수의 이름을 나열한다.
- 열거형 내부에서 상수로 지정하는 것 외에 직접 생성이 불가능하다. 생성할 경우 컴파일 오류가 발생한다.
- 추상 메서드는 선언하고 구현할 수 있는데, 이 경우 익명 클래스 방식을 사용한다.
- 사용할 때는 `static import` 를 사용하면 더욱 읽기 좋은 코드를 만들 수 있다.
- 주요 메서드
    - values() : 모든 ENUM 상수를 포함하는 배열을 반환한다.
    - valueOf(String name) : 주어진 이름과 일치하는 ENUM 상수를 반환한다.
    - name() : ENUM 상수의 이름을 문자열로 반환한다.
    - ordinal() : ENUM 상수의 선언 순서(0부터 시작)를 반환한다.
    - toString() : ENUM 상수의 이름을 문자열로 반환한다. name() 메서드와 유사하지만, `toString()`은 직접 오버라이드 할 수 있다.

> **주의!** ordinal() 은 가급적 사용하지 않는 것이 좋다.
> 
> - 값을 사용하다가 중간에 상수를 선언하는 위치가 변경되면 전체 상수의 위치가 모두 변경될 수 있기 때문이다.
> - 예를 들어, 기존 `GOLD`의 `ordinal()` 값인 `1`을 데이터베이스나 파일에 저장하고 있었는데, 중간에 `SILVER`가 추가되었다고 가정하자.
> - 이 경우 데이터베이스나 파일에 저장된 값은 그대로 `1`로 유지되지만, 애플리케이션 상에서 `GOLD`의 `ordinal()` 값은 `2`가 된다.

## 열거형 예제

```java
// 기본 열거형
public enum Day {
	MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

// 값과 메서드를 가진 열거형
public enum OrderStatus {
	PENDING("P", "대기중"),
	PROCESSING("R", "처리중"),
	SHIPPED("S", "배송중"),
	DELIVERED("D", "배송완료"),
	CANCELLED("C", "취소");
	
	private final String code;
	private final String description;
	
	// 생성자
	OrderStatus(String code, String description) {
		this.code = code;
		this.description = description;
	}
	
	// getter 메서드
	public String getCode() {
		return code;
	}
	
	public String getDescription() {
		return description;
	}
	
	// 정적 메서드
	public static OrderStatus fromCode(String code) {
		for (OrderStatus status : OrderStatus.values()) {
			if (status.code.equals(code)) {
				return status;
			}
		}
		throw new IllegalArgumentException("Ivalid code: " + code);
	}
}
```

```java
// 열거형 사용 예제
public class EnumMain {
	public static void main(String[] args) {
		// 열거형 사용
		Day today = Day.MONDAY;
		
		// switch문에서 사용
		switch (today) {
			case MONDAY:
			case FRIDAY:
				System.out.println("평일입니다.");
				break;
			case SATURDAY:
			case SUNDAY:
				System.out.println("주말입니다.");
				break;
		}
	
		// OrderStatus 사용
		OrderStatus status = OrderStatus.PENDING;
		System.out.println(status.getDescription()); // 대기중
		
		// 모든 값 순회
		for (OrderStatus status : OrderStatus.values()) {
			System.out.println(status.name() + ": " + status.getDescription());
		}
		
		// 코드로 찾기
		OrderStatus found = OrderStatus.fromCode("S");
		System.out.println(found); // SHIPPED
	}
}
```

- Enum의 장점
    - 타입 안정성: 컴파일 시점에 타입 체크
    - 상수 그룹화: 관련 상수들을 하나로 관리
    - 싱글톤 보장: 각 열거 상수는 JVM 내에서 하나만 존재
    - `switch`문 지원: 가독성 좋은 코드 작성 가능

# 내부 클래스(Inner Class)

## 종류와 구분

- **중첩 클래스는 총 네 가지가 있고, 크게 두 가지로 분류할 수 있다.**
    - 정적 중첩 클래스 → 정적 변수와 같이 앞에 `static`이 붙어있다.
    - 내부 클래스 종류
        - 내부 클래스 → 인스턴스 변수와 같이 앞에 `static`이 붙어있지 않다.
        - 지역 클래스 → 지역 변수와 같이 코드 블럭 안에서 클래스를 정의한다.
        - 익명 클래스 → 지역 클래스의 특별한 버전이다.

- 중첩과 내부를 분류하는 핵심
    - 바깥 클래스 입장에서 볼 때 안에 있는 클래스가 나의 인스턴스에 소속이 되는가 되지 않는가 차이이다.
    - 정적 중첩 클래스는 바깥 클래스와 전혀 다른 클래스이다. 따라서 바깥 클래스의 인스턴스에 소속되지 않는다.
    - 내부 클래스는 바깥 클래스를 구성하는 요소이다. 따라서 바깥 클래스의 인스턴스에 소속된다.

- 정적 중첩 클래스는 앞에 `static`이 붙는다.
    - 자신의 멤버에는 당연히 접근할 수 있다.
    - 바깥 클래스의 인스턴스 멤버에는 접근할 수 없다.
    - 바깥 클래스의 클래스 멤버에는 접근할 수 있다.

- 내부 클래스는 앞에 `static`이 붙지 않는다. 쉽게 이야기해서 인스턴스 멤버가 된다.
    - 자신의 멤버에는 당연히 접근할 수 있다.
    - 바깥 클래스의 인스턴스 멤버에 접근할 수 있다.
    - 바깥 클래스의 클래스 멤버에 접근할 수 있다.

- 지역 클래스는 내부 클래스의 종류 중 하나로, 지역 변수와 같이 코드 블럭 안에서 정의된다.
    - 자신의 인스턴스 변수에 접근할 수 있다.
    - 자신이 속한 코드 블럭의 지역 변수에 접근할 수 있다.
    - 자신이 속한 코드 블럭의 매개변수에 접근할 수 있다. 매개변수도 지역변수의 한 종류이다.
    - 바깥 클래스의 인스턴스 멤버에 접근할 수 있다. (지역클래스도 내부클래스의 한 종류)
    - 지역 클래스가 접근하는 지역 변수는 절대로 중간에 값이 변하면 안된다. 따라서 `final`로 선언하거나 또는 사실상 `final`이어야 한다.

- 익명 클래스는 지역 클래스의 특별한 종류의 하나인데, 클래스의 이름이 없다는 특징이 있다.
    - 이름 없는 지역 클래스를 선언하면서 동시에 생성한다.
    - 익명 클래스를 사용할 때는 상위 클래스나 인터페이스가 필요하다. 부모 클래스를 상속 받거나, 또는 인터페이스를 구현해야 한다.
    - 익명 클래스는 말 그대로 이름이 없기 때문에, 생성자를 가질 수 없다. (기본 생성자만 사용됨)
    - 익명 클래스는 `AnonymousOuter$1`과 같이 자바 내부에서 바깥 클래스 이름 + `$` + 숫자로 정의된다. 익명 클래스가 여러개면 `$1`, `$2`, `$3`으로 숫자가 증가하면서 구분된다.
    - 단 한 번만 생성할 수 있기 때문에 여러 번 생성이 필요하다면 사용할 수 없다.

## 예제 코드

```java
public class OuterClass {
	private int outerField = 10;
	private static int staticField = 20;
	
	// 1. 내부 클래스
	public class InnerClass {
		public void display() {
			System.out.println("outerField = " + outerField);
			System.out.println("staticField = " + staticField);
		}
	}
	
	// 2. 정적 중첩 클래스
	public static class StaticNestedClass {
		public void display() {
			// System.out.println("outerField = " + outerField); // non-static 필드 접근 불가
			System.out.println("staticField = " + staticField); // static 필드만 접근 가능
		}
	}
	
	// 3. 지역 클래스
	public void methodWithLocalClass() {
		final int localVal = 5;
		
		class LocalClass() {
			public void display() {
				System.out.println("outerField = " + outerField);
				System.out.println("staticField = " + staticField);
				System.out.println("localVal = " + localVal); // final 혹은 사실상 final만 접근 가능
			}
		}
	}
	
	// 4. 익명 클래스
	public void createAnonymousClass() {
		Runnable runnable = new Runnable() {
			@Override
			public void run() {
				System.out.println("익명 클래스");
			}
		};
		
		// Java 8+ 람다 표현식
		Runnable lambdaRunnable = () -> System.out.println("람다 실행");
	}
}
```

```java
// 사용 에제
public class InnerClassMain {
	public static void main(String[] args) {
		Outerclass outer = new OuterClass();
		
		// 내부 클래스
		OuterClass.InnerClass inner = outer.new InnerClass();
		inner.display();
		
		// 정적 중첩 클래스
		OuterClass.StaticNestedClass nested = new OuterClass.StaticNestedClass();
		nested.display();
		
		// 지역 클래스
		outer.methodWithLocalClass();
		
		// 익명 클래스
		outer.createAnonymousClass();
	}
}
```

- 내부 클래스 사용 시기
    - 내부 클래스: 외부 클래스와 밀접한 관계이고 외부 인스턴스 없이 사용이 불가할 때
    - 정적 중첩 클래스: 외부 클래스의 인스턴스와 무관하게 사용할 때
    - 지역 클래스: 특정 메서드 내에서만 사용할 때
    - 익명 클래스: 일회성 구현이 필요할 때 (Java 8+ 람다 선호)

# 람다

- Java 8부터 도입된 기능으로, 함수를 간결하게 표현할 수 있는 방법이다.
- 익명 함수를 지원하여 코드의 가독성을 높이고 불필요한 코드를 줄이는 데 유용하다.
- 오직 단일 추상 메서드를 가지는 인터페이스에만 할당할 수 있다.
- 메서드나 함수는 다음과 같이 표현한다.
    
    ```java
    반환타입 메서드명(매개변수) {
    		본문
    }
    ```
    
- 람다는 다음과 같이 간결하게 표현한다.
    
    ```java
    (매개변수) -> {본문}
    ```
    
    - 람다는 익명 함수이다. 따라서 이름이 없다.

- 단일 표현식인 경우 본문의 중괄호(`{}`)와 `return` 키워드를 모두 생략할 수 있다.
    
    ```java
    (int a, int b) -> a + b;
    ```
    
    - 중괄호를 사용할 경우에는 반드시 `return` 키워드를 포함해야 한다.
    - `return` 키워드를 명시적으로 사용하는 경우 중괄호를 사용해야 한다.
- 자바 컴파일러는 람다가 사용되는 함수형 인터페이스의 메서드 타입을 기반으로 람다의 매개변수와 반환값의 타입을 추론한다. 따라서 람다는 타입을 생략할 수 있다.
    
    ```java
    @FunctionalInterface
    public interface MyFunction {
    	int apply(int a, int b);
    }
    
    public class LambdaMain1 {
    	public static void main(String[] args) {
    		MyFunction function1 = (int a, int b) -> a + b; // 타입 직접 입력
    		MyFunction function2 = (a, b) -> a + b; // 타입 추론 사용
    	}
    }
    ```
    
- 매개변수가 정확히 하나이면서 타입을 생략하고 이름만 있는 경우 소괄호(`()`)를 생략할 수 있다.
    - 매개변수가 없거나, 둘 이상인 경우 소괄호(`()`)가 필수적이다.
    
    ```java
    interface MyCall {
    	int call(int value);
    }
    
    public class LambdaMain2 {
    	public static void main(String[] args) {
    		MyCall call1 = (int value) -> value * 2; // 기본 형태
    		MyCall call2 = (value) -> value * 2; // 타입 추론
    		MyCall call3 = value -> value * 2; // 소괄호 생략 가능
    	}
    }
    ```
    

---

# String

## String의 특징

- `String`은 클래스이다. 따라서 기본형이 아닌 참조형이다.
- 문자열은 매우 자주 사용되므로 편의상 쌍따옴표로 문자를 감싸면 자바 언어에서 `new String()`으로 변경해준다.
- 이 경우 성능 최적화를 위해 문자열 풀을 사용하는데, 여기서 풀(Pool)은 공용 자원을 모아둔 곳을 뜻한다.
- 문자열 풀에 필요한 `String` 인스턴스를 미리 만들어두고 여러 곳에서 재사용할 수 있다면 성능과 메모리를 더 최적화 할 수 있다.
- 문자열 풀은 힙 영역을 사용한다. 그리고 문자열 풀에서 문자를 찾을 때는 해시 알고리즘을 사용하기 때문에 매우 빠른 속도로 원하는 `String` 인스턴스를 찾을 수 있다.
- `String`은 **불변(Immutable)**이다. 한 번 생성된 문자열은 절대 내부의 문자열 값을 변경할 수 없다.
- `String`이 내부의 값을 변경할 수 있다면, 기존에 문자열 풀에서 같은 문자를 참조하는 변수의 모든 문자가 함께 변경되는 문제가 발생한다.
- `String` 인스턴스가 `new String()`으로 만들어진 것인지, 문자열 리터럴로 만들어진 것인지 확인할 수 있는 방법이 없기 때문에 문자열 비교는 항상 `equals()`를 사용해서 동등성 비교를 해야 한다.

```java
String str1 = "Hello";
String str2 = "Hello";
String str3 = new String("Hello");

System.out.println(str1 == str2); // true (String pool)
System.out.println(str1 == str3); // false (다른 객체)
System.out.println(str1.equals(str3)); // true (같은 내용)

// 문자열 수정 시 새 객체 생성
String str4 = str1.concat(" World");
System.out.println(str1); // Hello
System.out.println(str4); // Hello World
```

## 주요 메서드

```java
public class StringMain {
	public static void main(String[] args) {
		String str = "   Hello Java World   ";
		
		// 길이와 문자 접근
		System.out.println("길이: " + str.length());
		System.out.println("5번째 문자: " + str.charAt(5));
		
		// 부분 문자열
		System.out.println(str.substring(0, 12)); // 0번 인덱스부터 12개(0~11)의 인덱스
		
		// 검색
		System.out.println(str.indexOf("Java"));
		System.out.println(str.contains("Java"));
		System.out.println(str.startsWith("     Hello"));
		System.out.println(str.endsWith("World   "));
		
		// 반환
		System.out.println(str.toLowerCase()); // 소문자로 변환
		System.out.println(str.toUpperCase()); // 대문자로 변환
		System.out.prinltn(str.trim()); // 앞위 공백 제거
		System.out.println(str.replace("Java", "Python")); // 치환
		
		// 분할과 결합
		String[] words = str.trim().split(" ");
		System.out.println(Arrays.toString(words));
		
		String joined = String.join("-", words);
		System.out.println(joined);
		
		// 형식화
		String formatted = String.format("이름: %s, 나이: %d", "홍길동", 25);
		System.out.println(formatted);
	}
}
```

# StringBuilder와 StringBuffer

## 문자열 클래스

| **구분** | **String** | **StringBuilder** | **StringBuffer** |
| --- | --- | --- | --- |
| 불변성 | 불변 | 가변 | 가변 |
| 성능 | 느리다. (많은 객체 생성) | 가장 빠르다. | 상대적으로 느리다. |
| 스레드 안정성 | 안전하다. (변경 불가) | 안전하지 않다.(동기화 없음) | 안전하다.(동기화 제공) |
| 사용 환경 | 일반 문자열 처리 | 단일 스레드, 빠른 처리 | 멀티 스레드 환경 필요 시 |

> **참고 : StringBuilder vs StringBuffer**
> 
> 
> `StringBuilder`와 `StringBuffer`는 똑같은 기능을 수행하는 클래스이다.
> 
> `StringBuilder`는 멀티 스레드 상황에 안전하지 않지만 동기화 오버헤드가 없으므로 속도가 빠르다.
> 
> `StringBuffer`는 내부에 동기화가 되어 있어서, 멀티 스레드 상황에 안전하지만 동기화 오버헤드로 인해 성능이 느리다.
> 

### StringBuilder

- 자바가 제공하는 가변(Mutable) 문자열 클래스이다.
- 가변은 내부의 값을 바로 변경할 수 있기 때문에 새로운 객체를 생성하지 않아도 되므로 성능과 메모리 사용 부분에서 더 효율적이다.

- **가변(Mutable)**
    - `String`은 불변하다. 즉, 한 번 생성되면 그 내용을 바꿀 수 없다.
    - 따라서 문자열에 변화를 주려고 할 때마다 새로운 `String` 객체가 생성되고, 기존 객체는 버려진다.
    - 이 과정에서 메모리와 처리 시간을 더 많이 소모한다.
- **불변(Immutable)**
    - `StringBuilder`는 가변적이다.
    - 하나의 `StringBuilder` 객체에서 문자열을 추가, 삭제, 수정할 수 있으며, 새로운 객체를 생성하지 않는다.
    - 이로 인해 메모리 사용을 줄이고 성능을 향상시킬 수 있다. 단, 사이드 이펙트를 주의해야 한다.

- `StringBuilder`를 직접 사용하는 것이 더 좋은 경우
    - 반복문에서 반복해서 문자를 연결할 때
    - 조건문을 통해 동적으로 문자열을 조합할 때
    - 복잡한 문자열의 특정 부분을 변경해야 할 때
    - 매우 긴 대용량 문자열을 다룰 때

### StringBuffer

- 자바가 제공하는 또 다른 가변(Mutable) 문자열 클래스이다.
- `StringBuilder`와 거의 동일한 기능을 제공하지만, 멀티스레드 환경에서 안전(Thread-safe)하도록 설계되어 있다.
- 모든 주요 메서드를 `synchronized` 키워드로 보호하여 여러 스레드가 동시에 같은 `StringBuffer` 인스턴스에 접근할 경우, 데이터 무결성을 보장할 수 있다.

- `StringBuffer`를 직접 사용하는 것이 더 좋은 경우
    - 멀티스레드 환경에서 동일한 문자열 객체를 여러 스레드가 동시에 수정해야 할 때
    - 다중 사용자 요청에 대해 동일 객체 접근이 발생하는 상황

## 사용 예제

```java
public class StringBuilderExample {
	public static void main(String[] args) {
		// StringBuilder 사용
		StringBuilder sb = new StringBuilder("Hello");
		
		// 문자열 추가
		sb.append(" World");
		sb.append(" Java").append(" Programming"); // 메서드 체이닝
		System.out.println(sb); // Hello World Java Programming
		
		// 삽입
		sb.insert(6, "Beautiful ");
		System.out.println(sb); // Hello Beautiful World Java Programming
		
		// 삭제
		sb.delete(6, 16); // 6번째 인덱스부터 16번째 전 인덱스(15)까지
		System.out.println(sb); // Hello World Java Programming
		
		// 역순
		sb.reverse();
		System.out.println(sb);
		
		// 성능 비교
		long start = System.currentTimeMillis();
		
		// String 연결 (비효율적)
		String str1 = "";
		for (int i = 0; i < 10000; i++) {
			str1 += i;
		}
		
		long end = System.currentTimeMillis();
		System.out.println("String: " + (end - start) + "ms");
		
		// StringBuilder (효율적)
		start = System.currentTimeMillis();
		
		StringBuilder str2 = new StringBuilder();
		for (int i = 0; i < 10000; i++) {
			str2.append(i);
		}
		
		end = System.currentTimeMillis();
		System.out.println("StringBuilder: " + (end - start) + "ms");
	}
}
```

# Math 클래스

## 수학 연산 메서드

- `Math` 클래스는 모든 메서드가 `static`이므로 객체 생성 없이 사용이 가능하다.
- `Math`는 수 많은 수학 문제를 해결해주는 클래스이다.
- 너무 많은 기능을 제공하기에 알아두기만 하고 실제 필요할 때 검색하거나 API 문서를 찾아보자.

```java
public class MathExample {
	public static void main(String[] args) {
		// 기본 연산
		System.out.println("절대값: " + Math.abs(-10)); // 10
		System.out.println("최대값: " + Math.max(10, 20)); // 20
		System.out.println("최소값: " + Math.min(10, 20); // 10
		
		// 제곱과 제곱근
		System.out.println("2의 3제곱: " + Math.pow(2, 3)); // 8.0
		System.out.println("16의 제곱근: " + Math.sqrt(16)); // 4.0
		System.out.println("27의 세제곱근: " + Math.cbrt(27)); // 3.0
		
		// 반올림, 올림, 내림
		double num = 3.7;
		System.out.println("반올림: " + Math.round(num)); // 4
		System.out.println("올림: " + Math.ceil(num)); // 4.0
		System.out.println("내림: " + Math.floor(num)); // 3.0
		
		// 삼각함수
		double angle = Math.PI / 4; // 45도
		System.out.println("sin(45°): " + Math.sin(angle));
		System.out.println("cos(45°): " + Math.cos(angle));
		System.out.println("tan(45°): " + Math.tan(angle));
		
		// 로그
		System.out.println("자연로그: " + Math.log(Math.E)); // 1.0
		System.out.println("상용로그: " + Math.log10(100)); // 2.0
		
		// 난수 생성
		System.out.println("0~1 난수: " + Math.random());
		
		// 1~100 사이의 정수 난수
		int randomInt = (int) (Math.random() * 100) + 1;
		System.out.println("1~100 난수: " + randomInt);
		
		// 상수
		System.out.println("원주율: " + Math.PI);
		System.out.println("자연상수: " + Math.E);
	}
}
```

## 실용적인 활용 예제

```java
public class MathUtilExample {
	// 두 점 사이의 거리 계산
	public static double distance(int x1, int y1, int x2, int y2) {
		return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
	}
	
	// 로또 번호 생성 (1 ~ 45 중 6개)
	public static int[] generateLotto() {
		Set<Integer> numbers = new HashSet<>();
		while (numbers.size() < 6) {
			numbers.add((int) (Math.random() * 45) + 1);
		}
		return numbers.stream().sorted().mapToInt(i -> i).toArray();
	}
	
	public static void main(String[] args) {
		System.out.println("거리: " + distance(0, 0, 3, 4);
		System.out.println("로또: " + Arrays.toString(generateLotto()));
	}
}
```
