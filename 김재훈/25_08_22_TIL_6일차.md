예비군 훈련으로 인한 개인 공부

---

# 난수 생성

## Math.random()

- `java.lang.Math` 클래스에 포함된 정적(static) 메서드이다.
- 0.0 이상 1.0 미만의 double형 난수를 반환한다.
- seed(시드) 값은 내부적으로 시스템 시간이 자동으로 사용되어 사용자 제어가 불가하다.
- 사용이 간단하지만 통제력이나 다양성이 적다.
- Thread-safe (여러 스레드에서 동시에 호출 가능)
- 기본 문법
    
    ```java
    double random = Math.random(); // 0.0 <= random < 1.0
    
    int randomInt = (int) (Math.random() * 10) + 1; // 1 <= randomInt < 10 정수
    ```
    

## new Random()

- `java.util.Random` 클래스의 인스턴스를 생성하여 난수를 발생시킨다.
- 다양한 타입(int, long, float, boolean 등)의 난수를 생성할 수 있다.
- seed 지정이 가능하므로 동일한 난수 시퀀스를 재현할 수 있다.
- 게임, 시뮬레이션, 테스트 등 난수의 제어가 필요한 경우에 적합하다.
- 인스턴스 생성이 필요하여 반복 호출 시 비효율적일 수 있다.
- Thread-safe 하지 않기 때문에 별도 동기화가 필요하다.
- 기본 문법
    
    ```java
    Random random = new Random(); // seed 없이 생성
    Random random = new Random(123); // seed 지정 가능
    int r = random.nextInt(10); // 0~9 사이의 난수
    ```
    
- 다양한 메서드
    - `nextInt()` : 정수
    - `nextDouble()` : 실수 (0.0 ~ 1.0)
    - `nextBoolean()` : `true` 또는 `false`
    - `nextLong()`, `nextFloat()` 등 다양한 메서드가 있다.

---

# 객체지향 기초

## 메서드 오버로딩

- 오버로딩이란 같은 이름의 메서드를 여러 개 정의하는 것이다.
- 매개변수의 개수나 타입이 다르면 같은 이름의 메서드도 여러 개 정의할 수 있다.
- 매개변수의 개수와 타입을 같게 하고 반환값만 다르게 하는 것은 오버로딩이 아니다.
- 예제
    
    ```java
    public class Printer {
    	public void print(int value) {
    		System.out.println("정수: " + value);
    	}
    	
    	public void print(double value) {
    		System.out.println("실수: " + value);
    	}
    	
    	public void print(String value) {
    		System.out.println("문자열: " + value);
    	}
    	
    	public void print(int x, int y) {
    		System.out.println("좌표: (" + x + ", " + y + ")");
    	}
    	
    	// 가변 매개변수
    	public void print(String... values) {
    		System.out.print("여러 문자열: ");
    		for (String value : values) {
    			System.out.print(value + " ");
    		}
    		System.out.println();
    	}
    	
    	/*
    	// 가변 매개변수 대신 배열로 전달하는 방법
    	public void print(String[] values) {
    		System.out.print("여러 문자열: ");
    		for (String value : values) {
    			System.out.print(value + " ");
    		}
    		System.out.println();
    	}
    	*/
    }
    ```
    
    ```java
    public class PrinterMain {
    	public static void main(String[] args) {
    		Printer printer = new Printer();
    		
    		printer.print(100);
    		printer.print(3.14);
    		printer.print("Hello");
    		printer.print(10, 20);
    		printer.print("Java", "Python", "JavaScript");
    	}
    }
    
    /*
    실행 결과
    정수: 100
    실수: 3.14
    문자열: Hello
    좌표: (10, 20)
    여러 문자열: Java Python JavaScript
    */
    ```
    

## 생성자

### 생성자란?

- 객체가 생성될 때 자동으로 호출되는 특별한 메서드로, 객체의 초기화를 담당한다.
- 클래스 이름과 동일한 이름을 가져야 하며, 반환 타입이 없다. (void도 쓰지 않는다.)
- 매개변수가 없는 생성자를 기본 생성자라 한다.
- 클래스에 생성자가 하나도 없으면, 자바 컴파일러가 기본 생성자를 자동으로 만들어준다.
- 생성자가 하나라도 있으면 자바는 기본 생성자를 만들지 않는다.
- 생성자 예제
    
    ```java
    public class Book {
    	String title;
    	String author;
    	int price;
    	
    	// 기본 생성자 (생략 가능)
    	public Book(){
    		this("제목없음", "작자미상", 0);
    	}
    	
    	// 매개변수가 1개인 생성자
    	public Book(String title) {
    		this(title, "작자미상", 0);
    	}
    	
    	// 매개변수가 3개인 생성자 (모든 필드 초기화)
    	public Book(String title, String author, int price) {
    		this.title = title;
    		this.author = author;
    		this.price = price;
    	}
    	
    	public void displayInfo() {
    		System.out.println("제목: " + title);
    		System.out.println("저자: " + author);
    		System.out.println("가격: " + price + "원");
    		System.out.println("---");
    	}
    }
    ```
    
- 생성자 활용
    
    ```java
    public class BookMain {
    	public static void main(String[] args) {
    		// 다양한 생성자 사용
    		Book book1 = new Book();
    		Book book2 = new Book("Java");
    		Book book3 = new Book("Spring", "KIM", 20000);
    		
    		book1.displayInfo();
    		book2.displayInfo();
    		book3.displayInfo();
    	}
    }
    
    /*
    실행 결과
    제목: 제목없음
    저자: 작자미상
    가격: 0원
    ---
    제목: Java
    저자: 작자미상
    가격: 0원
    ---
    제목: Spring
    저자: KIM
    가격: 20000원
    ---
    */
    ```
    

### this와 this()

- `this` : 현재 인스턴스를 가리키는 참조 변수
    - 매개변수의 이름과 멤버 변수의 이름이 같은 경우 `this`를 사용해서 둘을 명확하게 구분한다.
    - 인스턴스 자신의 참조값을 가리켜 메서드의 매개변수가 아닌 멤버 변수로 접근할 수 있다.
    - `this`는 생략할 수 있다. 변수를 찾을 때 가까운 지역변수(매개변수도 지역변수다)를 먼저 찾고, 없으면 그 다음으로 멤버 변수를 찾는다. 멤버 변수도 없으면 오류가 발생한다.
- `this()` : 같은 클래스의 다른 생성자를 호출
    - 생성자 내부에서 자신의 생성자를 호출하는 것으로, 자신의 참조값을 가리킨다.
    - 생성자의 첫 번째 줄에서만 사용이 가능하며, 그렇지 않으면 오류가 발생한다.
- 활용 예제
    
    ```java
    public class Person {
    	private String name;
    	private int age;
    	private String address;
    	
    	// this를 사용한 필드 접근
    	public Person(String name, int age) {
    		this.name = name; // this.name 은 필드(멤버 변수), name 은 매개변수
    		this.age = age;
    	}
    	
    	// 메서드에서 this 사용
    	// 해당 메서드는 매개변수가 없으므로 this를 생략해도 멤버 변수로 접근한다.
    	public void introduce() {
    		System.out.println("안녕하세요, 저는 " + this.name + "입니다.");
    		System.out.println("나이는 " + this.age + "입니다.");
    	}
    	
    	// this를 반환하는 메서드 (메서드 체이닝)
    	public Person setAddress(String address) {
    		this.address = address;
    		return this; // 현재 객체를 반환
    	}
    	
    	public Person setAge(int age) {
    		this.age = age;
    		return this;
    	}
    	
    	// 다른 메서드 호출 시 this 사용 (선택적)
    	public void displayAll() {
    		this.introduce(); // this 생략 가능
    		System.out.println("주소: " + address);
    	}
    }
    
    ```
    
    ```java
    // 사용 예제
    public class PersonMain {
    	public static void main(String[] args) {
    		Person person = new Person("김철수", 25);
    		person.displayAll();
    		System.out.println("---");
    		
    		// 메서드 체이닝
    		person.setAddress("서울").setAge(26).displayAll();
    	}
    }
    
    /*
    실행 결과
    안녕하세요, 저는 김철수입니다.
    나이는 25입니다.
    주소: null
    ---
    안녕하세요, 저는 김철수입니다.
    나이는 26입니다.
    주소: 서울
    */
    
    ```
    

## 패키지와 import

### 패키지(package)란?

- 관련된 클래스들을 그룹화하는 디렉토리 구조이다. 컴퓨터에서 파일별로 모아둔 폴더를 생각하면 쉽다.
- 클래스의 충돌을 방지하고 관리를 용이하게 한다.
- 서로 관련된 클래스는 하나의 패키지에 모으고, 관련이 적은 클래스는 다른 클래스로 분리하는 것이 좋다.
- 명명 규칙
    - 패키지의 이름과 위치는 폴더(디렉토리) 위치와 같아야 한다.
    - 모두 소문자를 사용한다.
    - 관례적으로 도메인 역순을 사용한다. (예- com.example.project)
    - 예약어 사용을 금지한다.
    - 특수문자는 언더스코어(_)만 사용이 가능하다.

### 패키지 선언과 사용

```java
// 파일: com/mycompany/model/Prodejct.java
package com.mycompany.model;

public class Product {
	private String name;
	private int price;
	
	public Product(String name, int price) {
		this.name = name;
		this.price = price;
	}
	
	public void display() {
		System.out.println(name + ": " + price + "원");
	}
}
```

```java
// 파일: com/mycompany/service/ProductService.java
package com.mycompany.service

import com.mycompany.model.Product; // import 사용
import java.util.ArrayList; // Java 표준 라이브러리
import java.util.*; // 와일드카드 사용 (권장하지 않음)

public class ProductService {
	private ArrayList<Product> products;
	
	public ProductService() {
		products = new ArrayList<>();
	}
	
	public void addProduct(Product product) {
		products.add(product);
	}
	
	public void displayAll() {
		for (Product product : products) {
			product.display();
		}
	}
}
```

### import 사용 규칙

```java
// 1. 단일 클래스 import (권장)
import java.util.Scanner;
import java.util.ArrayList;

// 2. 와일드카드 import (비권장 - 가독성 저하)
import java.util.*;

// 3. static import (static 멤버 직접 사용)
import static java.lang.Math.PI;
import static java.lang.Math.sqrt;

public class MathExample {
	public static void main(String[] args) {
		// static import 덕분에 Math. 없이도 사용 가능
		double area = PI * 5 * 5;
		double root = sqrt(16);
		
		System.out.println("area = " + area);
		System.out.println("root = " + root);
	}
}

/*
실행 결과
area = 25
root = 4
*/
```

## static 키워드

### 자바 메모리 구조

- 자바 메모리 구조는 크게 메서드 영역, 스택 영역, 힙 영역 세 개로 나눌 수 있다.
    - **메서드 영역(Method Area):** 프로그램을 실행하는데 필요한 공통 데이터를 관리한다. 프로그램의 모든 영역에서 공유한다.
        - 클래스 정보: 클래스의 실행 코드(바이트 코드), 필드, 메서드와 생성자 코드 등 모든 실행 코드가 존재한다.
        - static 영역: `static` 변수들을 보관한다.
        - 런타임 상수 풀: 프로그램을 실행하는데 필요한 공통 리터럴 상수를 보관한다.
    - **스택 영역(Stack Area):** 자바 실행 시, 스레드 별로 하나의 실행 스택이 생성된다. 각 스택 프레임은 지역 변수, 중간 연산 결과, 메서드 호출 정보 등을 포함한다.
        - 스택 영역에 쌓이는 네모 박스를 하나의 스택 프레임이라 한다. 메서드를 호출할 때마다 하나의 스택 프레임이 쌓이고, 메서드가 종료되면 해당 스택 프레임이 제거된다.
    - **힙 영역(Heap Area):** 객체(인스턴스)와 배열이 생성되는 영역이다. 가비지 컬렉션(GC)이 이루어지는 주요 영역이며, 더 이상 참조되지 않는 객체는 GC에 의해 제거된다.

> **런타임 상수 풀에 대한 추가 학습**
> 
> - Constant Pool(상수 풀)은 `.class` 파일에서 필요한 Literal Constant, Type Field(지역 변수, 클래스 변수), Class 및 Method로의 모든 Symbolic Reference 등을 모아놓은 데이터 구조이다.
> - 이러한 상수 풀이 JVM에 올라갈 때 런타임 상수 풀(Runtime Constant Pool)이 된다.
> - ~~Heap 메모리의 확장성 때문에 특이하게도 static object와 String 관련 정보는 Method Area가 아닌 Heap Area에서 따로 보관하여 사용한다.~~
> - `String` 리터럴은 런타임 상수 풀에 저장되어 Method Area에서 관리되지만, `new` 키워드를 통한 문자열 객체나 일반 객체는 Heap 메모리에 생성된다.
> - static 필드의 정보는 Method Area에 저장되며, 해당 필드가 참조하는 객체는 Heap에 존재한다.
> - 그 외의 것들은 모두 Method Area에 보관하여 사용한다.

### static 변수

- 클래스 변수, 정적 변수라고도 한다.
- `static`이 붙은 멤버 변수는 인스턴스를 생성하지 않아도 클래스에 바로 접근해서 사용할 수 있고, 클래스 자체에 소속되어 있다.
- `static` 변수는 자바 프로그램을 시작할 때 딱 1개 만들어져 메모리에 올라간다. 인스턴스와는 다르게 보통 여러 곳에서 공유하는 목적으로 사용된다.
- **static 변수 접근 방법**
    - 인스턴스를 통한 접근
        - 정적 변수의 인스턴스를 통한 접근은 가능하지만 추천하지는 않는다.
        - 코드를 읽을 때 마치 인스턴스 변수에 접근하는 것처럼 오해할 수 있기 때문이다.
    - 클래스를 통한 접근
        - 정적 변수는 클래스에서 공용으로 관리하기 때문에 클래스를 통해서 접근하는 것이 더욱 명확하다.
        - 따라서 정적 변수에 접근할 때는 클래스를 통해서 접근하자.
- **변수와 생명주기**
    - 지역변수(매개변수 포함)
        - 지역 변수는 스택 영역에 있는 스택 프레임 안에 보관된다.
        - 메서드가 종료되면 스택 프레임이 제거 되는데, 이때 해당 스택 프레임에 포함된 지역 변수도 함께 제거된다. 따라서 지역 변수는 생존 주기가 짧다.
    - 인스턴스 변수
        - 인스턴스에 있는 멤버 변수를 인스턴스 변수라고 하는데, 인스턴스 변수는 힙 영역을 사용한다.
        - 힙 영역은 GC(가비지 컬렉션)가 발생하기 전까지는 생존하기 때문에 일반적으로 지역 변수보다 생존 주기가 길다.
    - 클래스 변수
        - 클래스 변수는 메서드 영역의 static 영역에 보관되는 변수이다.
        - 메서드 영역은 프로그램 전체에 사용하는 공용 공간이다.
        - 클래스 변수는 해당 클래스가 JVM에 로딩 되는 순간 생성되고, JVM이 종료될 때까지 생명주기가 이어진다. 가장 긴 생명주기를 가진다.

### static 메서드

- 메서드 앞에도 `static`을 붙일 수 있다. 이것을 정적 메서드 또는 클래스 메서드라 한다.
- 반대로 `static`이 붙지 않은 메서드는 인스턴스를 생성해야 호출할 수 있다. 이것을 인스턴스 메서드라 한다.
- 정적 메서드는 `static`이 붙은 정적 메서드나 정적 변수만 사용할 수 있고, 인스턴스 변수나 인스턴스 메서드를 사용할 수 없다.
    - 정적 메서드는 클래스의 이름을 통해 바로 호출할 수 있다. 그래서 인스턴스처럼 참조값의 개념이 없다.
    - 특정 인스턴스의 기능을 사용하기 위해서는 참조값을 알아야 하는데, 정적 메서드는 참조값 없이 호출한다.
    - 따라서 정적 메서드 내부에서 인스턴스 변수나 인스턴스 메서드를 사용할 수 없다.
- 반대로 모든 곳에서 `static`을 호출할 수 있다.
    - 정적 메서드는 공용 기능이다. 따라서 접근 제어자만 허락한다면 클래스를 통해 모든 곳에서 `static`을 호출할 수 있다.
- **정적 메서드 접근 방법**
    - `static` 메서드는 `static` 변수와 마찬가지로 클래스를 통해 바로 접근할 수 있고, 인스턴스를 통해서도 접근할 수 있다.
    - 인스턴스를 통한 접근
        - 정적 메서드의 경우 인스턴스를 통한 접근은 추천하지 않는다.
        - 코드를 읽을 때 마치 인스턴스 메서드에 접근하는 것처럼 오해할 수 있기 때문이다.
    - 클래스를 통한 접근
        - 정적 메서드는 클래스에서 공용으로 관리하기 때문에 클래스를 통해서 접근하는 것이 더욱 명확하다.
        - 따라서 정적 메서드에 접근할 때는 클래스를 통해서 접근하자.

### 활용 예제

```java
public class Student {
	// 인스턴스 필드
	String name;
	int score;
	
	// 클래스 필드 (모든 인스턴스가 공유)
	static int totalStudents = 0;
	static int totalScore = 0;
	
	// 생성자
	public Student(String name, int score) {
		this.name = name;
		this.score = score;
		totalStudent++;
		totalScore++;
	}
	
	// 인스턴스 메서드
	public void displayInfo() {
		System.out.println(name + ": " + score + "점");
	}
	
	// 클래스 메서드
	public static double getAverage() {
		// 인스턴스 변수인 name, score 접근 불가능
		// 인스턴스 메서드인 displayInfo() 접근 불가능
		if (totalStudents == 0) return 0;
		return (double) totalScore / totalStudents;
	}
	
	public static void displayStatistics() {
		System.out.println("전체 학생 수: " + totalStudents);
		System.out.println("전체 점수 합: " + totalScore);
		System.out.println("평균 점수: " + getAverage); // 클래스 메서드 접근 가능
	}
}
```

```java
public class StudentMain {
	public static void main(String[] args) {
		// static 메서드는 객체 생성 없이 호출 가능
		Student.displayStatistics();
		System.out.println("---");
		
		Student s1 = new Student("Kim", 85);
		Student s2 = new Student("Park", 92);
		Student s3 = new Student("Lee", 78);
		
		s1.displayInfo();
		s2.displayInfo();
		s3.displayInfo();
		System.out.println("---");
		
		Student.displayStatistics();
	}
}

/*
실행 결과
전체 학생 수: 0
전체 점수 합: 0
평균 점수: 0.0
---
Kim: 85점
Park: 92점
Lee: 78점
---
전체 학생 수: 3
전체 점수 합: 255
평균 점수: 85.0
*/
```
