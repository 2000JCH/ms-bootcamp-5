# 다형성(Polymorphism)

## 다형성이란?

- 객체지향 프로그래밍의 꽃이라 불리며, 이름 그대로 “다양한 형태”, “여러 형태”를 의미한다.
- 프로그래밍에서 하나의 객체가 여러 타입의 객체로 취급될 수 있는 능력을 의미한다.
- 프로그램 언어의 각 요소들(상수, 변수, 오프젝트, 함수, 메서드 등)이 다양한 자료형(type)에 속하는 것이 허가되는 성질을 의미한다.
- 반댓말은 단형성으로, 프로그램 언어의 각 요소가 한가지 형태만 가지는 성질을 가리킨다.

## System.out.println(…)

- `println`은 “인자를 출력하고 줄바꿈을 한다”는 기능이다.
- 여기에서 인자는 `int`, `float`, `double`, `String` 등 다양한 자료형이 될 수 있다.
- 중요한 건 메서드 이름이 같다는 것이다. 왜 메서드 이름이 같다는 것이 중요할까?

## 부모 타입으로 자식 타입을 참조

- 다형성이란 하나의 타입으로 여러 종류의 객체를 다루는 것이다.
- 부모 타입의 참조 변수로 부모 객체를 참조 (`Parent parent = new Parnet()`)
    - 부모 타입인 `Parent` 인스턴스를 생성하기 때문에 메모리 상에 `Parent`만 생성한다.
- 자식 타입의 참조 변수로 자식 객체를 참조 (`Child child = new Child()`)
    - 자식 타입인 `Child` 인스턴스를 생성하기 때문에 메모리 상에 `Child`와 `Parent` 모두 생성된다.
- **부모 타입의 참조 변수**로 **자식 객체**를 참조 (`Parent poly = new Child()`)
    - 자식 타입인 `Child` 인스턴스를 생성하기 때문에 메모리 상에 `Child`와 `Parent` 모두 생성된다.
    - 생성된 참조값은 `Parent` 타입의 변수인 `poly`에 담아둔다.
- 부모 타입은 자식 타입(더 하위 타입까지)을 담을 수 있지만, 자식 타입은 부모 타입을 담을 수 없다.
    - 가능한 예시) `Parent poly = new Child()`
    - 불가능한 예시) `~~Child poly = new Parent()~~`
- 상속 관계는 필요한 기능을 부모 방향으로 찾아 올라갈 수는 있지만 자식 방향으로 찾아 내려갈 수는 없다.
    - 따라서 자식 타입에 있는 기능을 호출하고 싶을 경우 캐스팅이 필요하다.
    - 혹은 자식 타입에서 메서드 오버라이딩을 한다면 해당 기능이 우선권을 가진다.

## 다형성 활용

```java
public class Zoo {
	public static void main(String[] args) {
		// 다형성: 부모 타입으로 자식 객체 참조
		Animal[] animals = new Animal[3];
		animals[0] = new Dog();
		animals[1] = new Cat();
		animals[2] = new Animal();
		
		System.out.println("=== 동물원의 동물들 ===");
		for (Animal animal : animals) {
			animal.makeSound(); // 각 동물의 오버라이딩된 메서드 호출
			animal.move();
			System.out.println("---");
		}
		
		// instanceof 연산자로 실제 타입 확인
		for (Animal animal : animals) {
			if (animal instanceof Dog) {
				Dog dog = (Dog) animal; // 다운캐스팅
				dog.wagTail();
			} else if (animal instanceof Cat) {
				Cat cat = (Cat) animal;
				cat.scratch();
			}
		}
	}
}
```

```java
//실행 결과
=== 동물원의 동물들 ===
멍멍!
강아지가 네 발로 뛰어다닙니다.
---
야옹~
고양이가 살금살금 걷습니다.
---
동물이 소리를 냅니다.
동물이 움직입니다.
---
꼬리를 흔듭니다.
할퀴기!
```

> **다운캐스팅과 업캐스팅 비교**
> 
> - 다운캐스팅 예제
>     
>     ```java
>     public class CastingMain {
>     	public static void main(String[] args) {
>     		// 부모 변수가 자식 인스턴스 참조(다형적 참조)
>     		Parent poly = new Child();
>     		// 단, 자식의 기능은 호출할 수 없다. 컴파일 오류 발생
>     		// poly.childMethod();
>     		
>     		// 일시적 다운캐스팅 - 해당 메서드를 호출하는 순간만 다운캐스팅
>     		((Child) poly).childMethod();
>     	}
>     }
>     ```
>     
>     - 캐스팅을 한다고 해서 `Parent poly`의 타입이 변하는 것은 아니다.
>     - 해당 참조값을 꺼내고 꺼낸 참조값이 `Child` 타입이 되는 것이다.
>     - `poly`의 타입은 `Parent`로 그대로 유지된다.
>     - 일시적 다운캐스팅을 사용하면 별도의 변수 없이 인스턴스의 자식 타입의 기능을 사용할 수 있다.
> - 업캐스팅 예제
>     
>     ```java
>     public class CastingMain {
>     	public static void main(String[] args) {
>     		Child child = new Child();
>     		Parent parent1 = (Parent) child; // 업캐스팅은 생략 가능, 생략 권장
>     		Parent parent2 = child; // 업캐스팅 생략
>     		
>     		parent1.parentMethod();
>     		parent2.parentMethod();
>     	}
>     }
>     ```
>     
>     - `Child` 타입을 `Parent` 타입에 대입해야 한다. 따라서 타입을 변환하는 캐스팅이 필요하다.
>     - 그런데 부모 타입으로 변환하는 경우에는 캐스팅 코드인 `(타입)`을 생략할 수 있다.
>     - 업캐스팅은 생략할 수 있지만, 다운캐스팅은 생략할 수 없다.
>     - 업캐스팅은 자주 사용하기 때문에 생략을 권장한다.

---

# 추상 클래스(Abstract Class)

## 추상화와 추상 클래스

- 추상화란?
    - 실제로는 존재하지 않지만 일반화 시킬 목적으로 만들어진 단어들이 있다.
    - 예) 가구, 자동차, 음식 등
- 추상 클래스란?
    - 이름 그대로 추상적인 개념을 제공하는 클래스이다. 따라서 실체인 인스턴스가 존재하지 않는다.
    - 상속을 목적으로 사용되고, 부모 클래스 역할을 담당한다.
    - 추상 클래스를 상속받는 자손이 인스턴스가 된다.
    - `abstract` 키워드를 사용하여 클래스를 정의한다.
    - 추상 클래스는 보통 1개 이상의 추상 메서드를 가진다. (추상 메서드가 없어도 오류가 발생하지는 않는다.)
        
        ```java
        public abstract class 클래스명 {
        ...
        }
        ```
        
- 추상 메서드란?
    - 상속 받는 자식 클래스가 반드시 오버라이딩 해야 하는 부모 클래스에 정의된 메서드를 의미한다.
    - 실체가 존재하지 않고 메서드 바디가 없다.
        
        ```java
        public abstract void 메서드명();
        ```
        
    - 추상 메서드가 하나라도 있는 클래스는 추상 클래스로 선언해야 한다.
        - 그렇게 하지 않으면 컴파일 오류가 발생한다.
        - 추상 메서드는 메서드 바디가 없기 때문에 작동하지 않는 메서드를 가진 불완전한 클래스이다.
        - 따라서 직접 생성하지 못하도록 추상 클래스로 선언해야 한다.
    - 추상 메서드는 상속 받는 자식 클래스가 반드시 오버라이딩 해서 사용해야 한다.
        - 그렇게 하지 않으면 컴파일 오류가 발생한다.
        - 추상 메서드는 자식 메서드가 반드시 오버라이딩 해야 하기 때문에 메서드 바디 부분이 없다.
        - 바디 부분을 만들면 컴파일 오류가 발생한다.
        - 오버라이딩 하지 않으려면 자식도 추상 클래스가 되어야 한다.

## 추상 클래스 예제

```java
// 추상 클래스
public abstract class Shape {
	protected String color;
	
	public Shape(String color) {
		this.color = color;
	}
	
	// 추상 메서드 (메서드 바디가 없음)
	public abstract double getArea();
	public abstract double getPerimeter();
	
	// 일반 메서드
	public void displayColor() {
		System.out.println("색상: " + color);
	}
}

// 구체적인 클래스
public class Circle extends Shape {
	private double radius;
	
	public Circle(String color, double radius) {
		super(color);
		this.radius = radius;
	}
	
	@Override
	public double getArea() {
		return Math.PI * radius * radius;
	}
	
	@Override
	public double getPerimeter() {
		return 2 * Math.PI * radius;
	}
}

// 구체적인 클래스
public class Rectangle extends Shape {
	private double width;
	private double height;
	
	public Rectangle(String color, double width, double height) {
		super(color);
		this.width = width;
		this.height = height;
	}
	
	@Override
	public double getArea() {
		return width * height;
	}
	
	@Override
	public double getPerimeter() {
		return 2 * (width + height);
	}
}
	
```

## 템플릿 메서드 패턴

- 여러 클래스에서 공통으로 사용하는 메서드를 템플릿화하는 패턴이다.
- 상위 클래스에서 정의하고, 하위 클래스마다 세부 동작 사항을 다르게 구현하는 패턴이다.
- 변하지 않는 기능은 상위 클래스에 만들어두고 자주 변경되어 확장할 기능은 하위 클래스에서 만드는 것이다.
- 상속이라는 기능을 극대화하여, 알고리즘의 뼈대를 맞추는 것에 초점을 둔다.
- 예제 코드
    
    ```java
    public abstract class Game {
    	// 템플릿 메서드
    	public final void play() {
    		initialize();
    		startPlay();
    		endPlay();
    	}
    	
    	// 추상 메서드 (하위 클래스에서 구현)
    	abstract void initialize();
    	abstract void startPlay();
    	abstract void endPlay();
    }
    
    public class Football extends Game {
    	@Override
    	void initialize() {
    		System.out.println("Football 게임 준비 중...");
    	}
    	
    	@Override
    	void startPlay() {
    		System.out.println("Footbal 게임 시작!");
    	}
    	
    	@Override
    	void endPlay() {
    		System.out.println("Football 게임 종료!");
    	}
    }
    
    public class Baseball extends Game {
    	@Override
    	void initialize() {
    		System.out.println("Baseball 게임 준비 중...");
    	}
    	
    	@Override
    	void startPlay() {
    		System.out.println("Baseball 게임 시작!");
    	}
    	
    	@Override
    	void endPlay() {
    		System.out.println("Baseball 게임 종료!");
    	}
    }
    ```
    
    ```java
    public class TemplateMethodMain {
    	public static void main(String[] args) {
    		Game game1 = new Football();
    		game1.play();
    		
    		System.out.println();
    		
    		Game game2 = new Baseball();
    		game2.play();
    	}
    }
    
    /*
    실행 결과
    Football 게임 준비 중...
    Football 게임 시작!
    Football 게임 종료!
    
    Basketball 게임 준비 중...
    Basketball 게임 시작!
    Basketball 게임 종료!
    */
    ```
    

---

# 인터페이스(Interface)

## 인터페이스란?

- 클래스가 반드시 구현해야 하는 메서드들의 집합을 정의하는 틀(약속)이다.
- 앞서 학습한 추상 클래스와 같지만 약간의 편의 기능이 추가되고, 다중 구현을 지원한다.
- 문법
    
    ```java
    [public] interface 인터페이스이름 (...)
    ```
    
- `인터페이스이름`은 Upper CamelCase로 작성된다.
- 클래스, 추상클래스, 인터페이스는 프로그램 코드와 메모리 구조상 모두 똑같이 자바에서는 `.class`로 다루어진다. 인터페이스를 작성할 때도 확장자가 `.java` 파일로 작성된다.
- 인터페이스의 필드는 모두 `public static final`이 모두 포함되었다고 간주한다.
- 인터페이스의 메서드는 모두 `public abstract`이며, 메서드에 `public abstract`는 생략이 권장된다.
- Java 8부터는 디폴트(`default`) 메서드와 정적(`static`) 메서드 선언이 가능해졌다.

## 인터페이스 선언과 구현

- 부모 클래스의 기능을 자식 클래스가 상속 받을 때, 클래스는 **상속** 받는다고 표현하지만, 인터페이스는 **구현**한다고 표현한다.
- 상속은 부모의 기능을 물려 받는 것이 목적이다.
- 인터페이스는 모든 메서드가 추상 메서드이므로 물려 받을 수 있는 기능이 없고, 오히려 인터페이스에 정의한 모든 메서드를 자식이 오버라이딩 해서 기능을 구현해야 한다.

```java
// 인터페이스 정의
public interface Drawable {
	void draw(); // public abstract가 자동으로 붙는다.
	void erase();
}
```

```java
// 인터페이스 정의
public interface Resizable {
	void resize(double factor);
}
```

```java
// 인터페이스 다중 구현
public class Photo implements Drawable, Resizable {
	private String filename;
	private int width;
	private int height;
	
	public Photo(String filename, int width, int height) {
		this.filename = filename;
		this.width = width;
		this.height = height;
	}
	
	@Override
	public void draw() {
		System.out.println(filename + " 사진을 화면에 그립니다.");
	}
	
	@Override
	public void erase() {
		System.out.println(filename + " 사진을 화면에서 지웁니다.");
	}
	
	@Override
	public void resize(double factor) {
		width = (int)(width * factor);
		height = (int)(height * factor);
		System.out.println("크기 조정: " + width + "x" + height);
	}
}
```

## 인터페이스의 default와 static 메서드 (Java 8+)

- 기존 인터페이스를 깨지 않고 기능을 확장하거나, 공통 로직을 제공하고자 할 때 유용하게 사용된다.
- **default method** (JDK 8에 추가된 메서드)
    - 인터페이스에서 메서드 본문(구현)을 가질 수 있도록 허용한 기능이다.
    - `default` 키워드를 사용하여 정의하며, 이를 통해 기존 인터페이스에 새로운 기능을 추가할 수 있다.
    - 기존에는 인터페이스에서 메서드를 추가하면, 그 인터페이스를 구현한 모든 클래스에서 해당 메서드를 무조건 구현해야 하는 호환성 문제가 발생했다.
    - `default method` 덕분에 인터페이스에서 메서드 추가 + 기존 코드와의 호환성 유지가 가능해졌다.
- **static method** (JDK 8에 추가된 메서드)
    - 정적 메서드를 인터페이스 안에 구현할수 있도록 하는 기능이다.
    - 인스턴스 생성 없이도 사용이 가능하며, 인터페이스 이름으로 직접 호출할 수 있다.
    - 유틸리티 메서드를 인터페이스와 관련된 문맥 안에 넣고 싶을 때 유용하다.
    - 구현체에서 상속되거나 재정의되지 않고, 인터페이스에 종속된 기능인 것을 강조할 수 있다.
- 예제
    
    ```java
    public interface Device {
    	// 추상 메서드
    	void turnOn();
    	void turnOff();
    	
    	// default 메서드
    	default void reset() {
    		System.out.println("기본 설정으로 초기화");
    	}
    	
    	// static 메서드
    	static void showInfo() {
    		System.out.println("기기 인터페이스 v1.0");
    	}
    }
    ```
    
    ```java
    public class Phone {
    	@Override
    	void turnOn() {
    		System.oout.println("폰 전원 On");
    	}
    	
    	@Override
    	void turnOff() {
    		System.out.println("폰 전원 Off");
    	}
    	
    	// default 메서드는 재정의하지 않아도 된다. (원한다면 오버라이드 가능하다.)
    	// static 메서드는 재정의가 불가능하다.
    }
    
    public class DeviceMain {
    	public static void main(String[] args) {
    		Device phone = new Phone(); // 다형성 활용
    		
    		phone.turnOn();
    		phone.turnOff();
    		phone.reset(); // default method
    		
    		Device.showInfo(); // static method
    	}
    }
    
    /*
    실행 결과
    폰 전원 On
    폰 전원 Off
    기본 설정으로 초기화
    기기 인터페이스 v1.0
    */
    ```
    

---

# 접근 제한자

## 종류

- `private`: 모든 외부 호출을 막는다.
- `default`(package-private): 같은 패키지 안에서 호출은 허용한다.
- `protected`: 같은 패키지 안에서 호출은 허용한다. 패키지가 달라도 상속 관계의 호출은 허용한다.
- `public`: 모든 외부 호출을 허용한다.

| 접근 제한자 | 클래스 내부 | 동일 패키지 | 자식 클래스 | 전체 |
| --- | --- | --- | --- | --- |
| public | O | O | O | O |
| protected | O | O | O | X |
| default | O | O | X | X |
| private | O | X | X | X |
- 8월 21일에도 같은 내용을 학습했으니, 해당 내용을 확인하자.

## 캡슐화

- 캡슐화는 데이터와 해당 데이터를 처리하는 메서드를 하나로 묶어서 외부에서의 접근을 제한하는 것이다.
- 캡슐화를 통해 데이터의 직접적인 변경을 방지하거나 제한할 수 있다.
- 쉽게 이야기해서 속성과 기능을 하나로 묶고, 외부에 꼭 필요한 기능만 노출시키고 나머지는 모두 내부로 숨기는 것이다.

- **데이터를 숨겨라**
    - 객체에는 속성(데이터)과 기능(메서드)이 있다. 캡슐화에서 가장 필수로 숨겨야 하는 것은 속성(데이터)이다.
    - 객체 내부의 데이터를 외부에서 함부로 접근하게 두면, 클래스 안에서 데이터를 다루는 모든 로직을 무시하고 데이터를 변경할 수 있다.
    - 객체의 데이터는 객체가 제공하는 기능인 메서드를 통해서 접근해야 한다.
- **기능을 숨겨라**
    - 객체의 기능 중 외부에서 사용하지 않고 내부에서만 사용하는 기능들이 있다. 이런 기능도 모두 감추는 것이 좋다.
    - 사용자 입장에서 꼭 필요한 기능만 외부에 노출하고, 나머지 기능은 모두 내부로 숨기자.

- 정리하자면, 데이터는 모두 숨기고 기능은 꼭 필요한 기능만 노출하는 것이 좋은 캡슐화이다.
- 예제
    
    ```java
    public class Employee {
    	private String name; // 외부에서 직접 접근 불가
    	private int salary; // 외부에서 직접 접근 불가
    	protected String department; // 같은 패키지와 자식 클래스에서 접근 가능
    	public String position; // 어디서든 접근 가능
    	
    	// 생성자
    	public Employee(String name, int salary) {
    		this.name = name;
    		setSalary(salary); // setter를 통한 유효성 검사
    	}
    	
    	// Getter
    	public String getName() {
    		return name;
    	}
    	
    	public int getSalary() {
    		return salary;
    	}
    	
    	// Setter with validation
    	public void setSalary(int salary) {
    		if (salary < 0) {
    			throw new IllegalArgumentException("급여는 0 이상이어야 합니다.");
    		}
    		this.salary = salary;
    	}
    	
    	// 정보 은닉과 캡슐화
    	public void raiseSalary(double percentage) {
    		if (percentage < 0 || percentage > 100) {
    			throw new IllegalArgumentException("인상률은 0~100% 사이여야 합니다.");
    		}
    		this.salary = (int) (salary * (i + percentage / 100));
    	}
    }
    ```
    

---

# 기타 중요 개념들

## 부모가 될 수 없는 클래스

- 상속을 금지 시키고 싶다면 클래스를 정의할 때 `final` 키워드를 사용하면 된다.
- `public final class 클래스명 {…}`

## instanceof 연산자 사용하기

- 객체가 특정 클래스의 인스턴스인지, 또는 특정 인터페이스를 구현하고 있는지 검사하는 연산자이다.
- 객체의 타입을 확인할 때 유용하며, 주로 다운캐스팅 전에 타입을 안전하게 확인하기 위해 사용한다.
- 문법
    
    ```java
    객체 instanceof 클래스이름
    ```
    
    - 결과는 `true` 또는 `false`인 **boolean 값**으로 반환된다.
- 예제
    
    ```java
    class Animal {}
    class Dog extends Animal {}
    
    public class InstanceofExample {
    	public static void main(String[] args) {
    		Animal animal = new Dog();
    		
    		// instanceof를 사용하여 타입 확인
    		if (animal instanceof Dog) {
    			System.out.println("animal은 Dog의 인스턴스입니다.");
    		}
    		
    		if (animal instanceof Animal) {
    			System.out.println("animal은 Animal의 인스턴스입니다.");
    		}
    		
    		if (animal instanceof Object) {
    			System.out.println("animal은 Object의 인스턴스입니다.");
    		}
    	}
    }
    
    /*
    실행 결과
    animal은 Dog의 인스턴스입니다.
    animal은 Animal의 인스턴스입니다.
    animal은 Object의 인스턴스입니다.
    */
    ```
    

### 주 사용 목적

1. 다운캐스팅 전 안전한 타입 확인
    
    ```java
    if (animal instanceof Dog) {
    	Dog dog = (Dog) animal;
    	dog.bark();
    }
    ```
    
2. 다형성 구조에서 여러 타입 처리
    
    ```java
    public void printAnimal(Animal animal) {
    	if (animal instanceof Dog) {
    		System.out.println("강아지입니다.");
    	} else if (animal instanceof Cat) {
    		System.out.println("고양이입니다.");
    	} else {
    		System.out.println("알 수 없는 동물입니다.");
    	}
    }
    ```
    

### 주의할 점

1. `null`에 대해 항상 `false` 반환
    
    ```java
    String str = null;
    System.out.println(str instanceof String); // false
    ```
    
2. 상속 관계가 없는 타입은 컴파일 에러
    
    ```java
    String str = "hello";
    // System.out.println(str instanceof Integer); // 컴파일 에러
    ```
    

### Java 16부터 **Pattern Matching for instanceof 도입**

- Java 16부터는 `instanceof`로 타입 확인과 동시에 변수를 선언할 수 있어 더욱 간결해졌다.
    
    ```java
    if (obj instanceof String s) {
    	System.out.println(s.length()); // String으로 자동 형변환
    }
    ```
    

## 싱글톤 패턴

- 디자인 패턴 중 하나로, 프로그램 전체에서 단 하나의 인스턴스만 존재하도록 보장하고, 해당 인스턴스에 대한 전역적인 접근 지점을 제공하는 구조이다.
- 공통 자원을 하나만 생성해야 할 때 사용하며, 메모리 절약 및 데이터 일관성 유지를 위해 사용한다.
- 클래스 내부에서만 객체 생성을 제어함으로써, 외부에서 마음대로 인스턴스를 생성하지 못하도록 제한한다.
- 테스트하기 어렵고, 멀티스레드 환경에서 신중하게 구현하지 않으면 동기화 문제가 발생한다는 단점이 있다.
- 핵심 구성 요소
    - `private static` 필드 : 클래스 안에 딱 하나만 생성된 인스턴스를 저장한다.
    - `private` 생성자 : 외부에서 `new` 키워드로 객체를 생성하는 것을 방지한다.
    - `public static` 필드 : 인스턴스를 반환하는 메서드 (주로 `getInstance()` 이름 사용)
- 기본 구조
    
    ```java
    public class Singleton {
    	// 1. private static 으로 유일한 인스턴스를 클래스 내부에 생성
    	private static Singleton instance = new Singleton();
    	
    	// 2. 외부에서 생성자를 호출할 수 없도록 private 으로 제한
    	private Singleton() {}
    	
    	// 3. 외부에서 인스턴스를 얻을 수 있는 유일한 메서드
    	public static Singleton getInstance() {
    		return instance;
    	}
    }
    ```
    
    ```java
    public class SingletonMain {
    	public static void main(String[] args) {
    		Singleton s1 = Singleton.getInstance();
    		Singleton s2 = Singleton.getInstance();
    		
    		System.out.println(s1 == s2); // true (같은 인스턴스)
    	}
    }
    ```
    

## 팩토리 메서드 패턴

- 객체 생성을 서브클래스에게 위임함으로써, 객체 생성 로직과 사용 로직을 분리하는 디자인 패턴이다.
- 객체 생성 코드를 별도의 팩토리 클래스로 분리해, 코드의 유연성과 확장성을 높이기 위한 목적이다.
- 확장에 열려 있고, 변경에 닫혀 있다. (OCP 원칙)
- `new` 클래스를 직접 사용하는 대신, 객체 생성을 서브 클래스나 팩토리 메서드에 위임한다.
- 부모 클래스에서는 객체 생성 방식만 선언하고, 실제 생성은 자식 클래스에서 처리한다.
- 클래스 수가 증가하고, 코드 추적이 어렵다는 단점이 있다.
- 예제 코드
    
    ```java
    public abstract class Vehicle {
    	public abstract void drive();
    }
    ```
    
    ```java
    public class Car extends Vehicle {
    	@Override
    	public void drive() {
    		System.out.println("자동차가 도로를 달립니다.");
    	}
    }
    
    public class Boat extends Vehicle {
    	@Override
    	public void drive() {
    		System.out.println("보트가 물 위를 달립니다.");
    	}
    }
    ```
    
    ```java
    public class VehicleFactory {
    	public static Vehicle createVehicle(String type) {
    		switch (type.toLowerCase()) {
    			case "car":
    				return new Car();
    			case "boat":
    				return new Boat();
    			default:
    				throw new IllegalArgumentException("Unknown vehicle type: " + type);
    		}
    	}
    }
    ```
    
    ```java
    // 사용 예제
    public class FactoryMain {
    	public static void main(String[] args) {
    		Vehicle v1 = VehicleFactory.createVehicle("car");
    		Vehicle v2 = VehicleFactory.createVehicle("boat");
    		
    		v1.drive();
    		v2.drive();
    	}
    }
    
    /*
    실행 결과
    자동차가 도로를 달립니다.
    보트가 물 위를 달립니다.
    */
    ```
    

---

# Object 클래스

## Object 클래스란?

- `java.lang` 패키지에 포함되는 클래스이며, 모든 클래스의 최상위 부모 클래스이다.
- `java.lang` 패키지는 모든 자바 애플리케이션에 자동으로 import 되므로, 별도로 명시해주지 않아도 된다.
- 클래스에 `extends`를 명시하지 않으면 자동으로 Object를 상속 받는다.
- 모든 객체가 공통으로 가져야 할 기본 메서드를 제공한다.

## 주요 메서드

- **toString()**
    - 객체의 정보를 문자열 형태로 제공해서 디버깅과 로깅에 유용하게 사용된다.
    - `Object` 클래스는 모든 클래스가 상속 받으므로 모든 클래스에서 이 메서드가 사용 가능하다.
    - 기본적으로는 객체의 참조값을 출력하지만 이 정보만으로는 객체의 상태를 적절히 나타내지 못한다.
    - 따라서 오버라이딩해서 보다 유용한 정보를 나타내는 것이 일반적이다.
    - 오버라이딩해서 객체의 참조값을 나타낼 수 없을 때 다음 코드를 사용하면 참조값을 출력할 수 있다.
        
        ```java
        String refValue = Integer.toHexString(System.identityHashCode(객체));
        System.out.println("refValue = " + refValue);
        ```
        
- **equals()**
    - 동등성 비교를 위한 메서드이다.
        - 동등성(Equality): `equals()` 메서드를 사용하여 두 객체가 논리적으로 동등한지 확인
        - 동일성(Identity): `==`연산자를 사용해서 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인
    - equals() 메서드를 구현할 때 지켜야 하는 규칙
        - 반사성(Reflexivity)**:** 객체는 자기 자신과 동등해야 한다. (`x.equals(x)`는 항상 `true`)
        - 대칭성(Symmetry)**:** 두 객체가 서로에 대해 동등하다고 판단하면, 이는 양방향으로 동일해야 한다. (`x.equals(y)` 가 `true`이면, `y.equals(x)`도 `true`)
        - 추이성(Transitivity)**:** 한 객체가 두 번째 객체와 동일하고, 두 번째 객체가 세 번째 객체와 동일하다면, 첫 번째 객체는 세 번째 객체와 동일해야 한다.
        - 일관성(Consistency)**:** 두 객체의 상태가 변경되지 않는 한, `equals()` 메서드는 항상 동일한 값을 반환해야 한다.
        - null에 대한 비교**:** 모든 객체는 `null`과 비교했을 때 `false`를 반환해야 한다.
    - 실제로 정확하게 동작하도록 구현하는 것은 쉽지 않고, IDE에서 정확한 `equals()` 코드를 자동으로 만들어 준다. (command + N)
    - 동등성 비교가 항상 필요한 것은 아니다. 필요한 경우에만 `equals()`를 재정의하면 된다.
    - `HashMap`, `HashSet` 등에서 올바르게 동작하기 위해서는 두 메서드를 함께 오버라이드 해야한다.
    - `equals()`가 `true`면 `hashCode()`도 같아야 한다.
    - `hashCode()`가 같다고 `equals`가 `true`인 것은 아니다.
- 예제 코드
    
    ```java
    public class Person {
    	private String name;
    	private int age;
    	
    	public Person(String name, int age) {
    		this.name = name;
    		this.age = age;
    	}
    	
    	// toString() 오버라이딩
    	@Override
    	public String toString() {
    		return "Person{name='" + name + "', age=" + age + "}";
    	}
    	
    	// equals() 오버라이딩
    	@Override
    	public boolean equals(Object obj) {
    		if (this == obj) return true;
    		if (obj == null || getClass() != obj.getClass()) return false;
    		
    		Person person = (Person) obj;
    		return age == person.age && name.equals(person.name);
    	}
    	
    	// hashCode() 오버라이딩
    	@Override
    	public int hashCode() {
    		int result = name != null ? name.hashCode() : 0;
    		result = 31 * result + age;
    		return result;
    	}
    }
    ```
    
    ```java
    public class ObjectMain {
    	public static void main(String[] args) {
    		Person p1 = new Person("Kim", 25);
    		Person p2 = new Person("Kim", 25);
    		Person p3 = new Person("Park", 23);
    		
    		// toString() 테스트
    		System.out.println(p1.toString()); // Person(name='Kim', age=25)
    		System.out.println(p1); // toString() 자동 호출
    		
    		// equals() 테스트
    		System.out.println(p1.equals(p2)); // true
    		System.out.println(p1.equals(p3)); // false
    		System.out.println(p1 == p2); // false (참조 비교)
    		
    		// hashCode() 테스트
    		System.out.println(p1.hashCode());
    		System.out.println(p2.hashCode()); // p1과 같다. (equals true면 hashCode도 같다.)
    		
    		// getClass() 테스트
    		System.out.println(p1.getClass().getName()); // Person
    		
    		// clone() 사용(을 위해서는 Cloneable 인터페이스 구현이 필요하다.)
    	}
    }
    ```
