# 제네릭(Generic)

- 클래스나 메서드를 선언할 때 사용할 데이터 타입을 미리 정하지 않고, 나중에 실제 사용할 때 타입을 지정할 수 있도록 해주는 문법이다.
- 컴파일 타임에 타입을 체크할 수 있어 안정성이 증가하고, 형변환이 필요 없어진다.

## 무엇이든 담을 수 있는 상자

```java
public class ObjectBox {
	private Object object;
	
	public void set(Object obj) {
		this.object = obj;
	}
	
	public Object get() {
		return this.object;
	}
}
```

- `ObjectBox` 사용 예제
    
    ```java
    public class ObjectBoxMain {
    	public static void main(String[] args) {
    		Objectbox box = new ObjectBox();
    		box.set("kim");
    		String str = (String) box.get(); // 형변환 필요
    		System.out.println(str.toUpperCase());
    		
    		box.set(new Iteger(5));
    		Integer i = (Integer) box.get(); // 형변환 필요
    		System.out.println(i.intValue());
    	}
    }
    ```
    
- `ObjectBox`의 문제점
    - 어떤 Object든 저장할 수 있고, 꺼낼 수 있지만 사용할 때 원래 타입으로 변환시키는 형변환 단계가 필요하다.
    - 잘못된 타입으로 캐스팅할 경우 런타임 오류가 발생할 수 있다.

## 제네릭을 사용한 GenericBox

```java
public class GenericBox {
	private T t;
	
	public void add(T obj) {
		this.t = obj;
	}
	
	public T get() {
		return this.t;
	}
}
```

- `GenericBox` 사용 예제
    
    ```java
    public class GenericBoxMain {
    	public static void main(String[] args) {
    		GenericBox<String> genericBox = new GenericBox<>();
    		genericBox.add("kim");
    		String str = genericBox.get(); // 형변환 불필요
    		System.out.prinltn(str.toUpperCase());
    		
    		// genericBox.add(new Integer(5)); // 컴파일 오류 발생
    	}
    }
    ```
    
- 제네릭 문법
    - `T`는 제네릭과 관련된 부분이다.
        - E - Element
        - K - Key
        - N - Number
        - T - Type
        - V - Value
        - S,U,V etc. - 2nd, 3rd, 4th types
    - 제네릭은 클래스 이름 뒤나, 메서드의 리턴타입 앞에 붙을 수 있다.
    - `<T>` 부분은 T라는 이름의 제네릭 타입을 선언한다는 것을 의미한다.
    - T는 Type의 약자이기 때문에 많이 사용하는 문자일 뿐 꼭 T를 사용해야 하는 것은 아니다.

- 제네릭의 장점
    - 정해진 타입만 사용하도록 강제할 수 있다.
    - 타입을 강제함으로써 컴파일 할 때 잘못된 타입의 값이 저장되는 것을 막을 수 있다.
    - 형변환(casting)이 불필요하다.
    - 컴파일 타임에 타입 안정성을 보장한다.

# 컬렉션 프레임워크

- 핵심 인터페이스
    
    ![image.png](attachment:6ff42fe5-bece-4b70-84c6-6ba10b55591b:image.png)
    
- `java.util.Collection`
    - 컬렉션 프레임워크에서 가장 기본이 되는 인터페이스이다.
    - 해당 인터페이스는 순서를 기억하지 않고, 중복을 허용하는 자료를 다루는 목적으로 만들어졌다.
- `java.util.List`
    - 순서가 중요한 자료를 다룰 때 사용하는 인터페이스이다.
    - Collection을 상속받음으로써 Collection이 가지고 있는 `add()`, `size()`, `iterator()` 메서드를 사용할 수 있다.
    - 순서를 알고 있다고 가정하기 때문에 특정 순서로 저장된 자료를 꺼낼 수 있는 `get(int)` 메서드를 가지고 있다.
- `java.util.Set`
    - 중복을 허용하지 않는 자료를 다룰 때 사용하는 인터페이스이다.
    - 중복을 허용하지 않는다는 것은 같은 값을 저장할 수 없다는 의미이다.
    - 같은 값을 여러 번 추가하여도 마지막 값 하나만 저장된다.
    - Set 인터페이스에 사용되는 객체들은 `equals()` 메서드와 `hashCode()` 메서드를 오버라이드 해야한다.
- `java.util.Iterator`
    - 자료구조에서 자료를 꺼내기 위한 목적으로 사용되는 인터페이스이다.
    - Iterator 패턴을 구현하고 있다.
- `java.util.Map`
    - 키(Key)와 값(Value)을 함께 저장하기 위한 목적으로 만들어진 인터페이스이다.
    - 같은 Key 값으로는 하나의 값만 저장할 수 있다.

## ArrayList

### 제네릭을 사용하지 않는 경우

```java
public class ListExam01 {
	public static void main(String[] args) {
		ArrayList list = new ArrayList();
		list.add("kim");
		list.add("lee");
		list.add("hong");
		
		String str1 = (String) list.get(0); // 형변환 필요
		String str2 = (String) list.get(1);
		String str3 = (String) list.get(2);
		
		System.out.println(str1);
		System.out.println(str2);
		System.out.println(str3);
	}
}

/*
실행 결과
kim
lee
hong
*/
```

### 제네릭을 사용하는 경우

```java
public class ListExam02 {
	public static void main(String[] args) {
		ArrayList<String> list = new ArrayList<>();
		list.add("kim");
		list.add("lee");
		list.add("hong");
		
		String str1 = list.get(0); // 형변환 불필요
		String str2 = list.get(1);
		String str3 = list.get(2);
		
		System.out.println(str1);
		System.out.println(str2);
		System.out.println(str3);
	}
}

/*
실행 결과
kim
lee
hong
*/
```

## Collection과 Iterator

### Collection 인터페이스 사용

```java
public class ListExam03 {
	public static void main(String[] args) {
		Collection<String> collection = new ArrayList<>();
		collection.add("kim");
		collection.add("lee");
		collection.add("hong");
		
		System.out.println(collection.size());
		
		Iterator<String> iter = collection.iterator();
		while (iter.hasNext()) {
			String str = iter.next();
			System.out.println(str);
		}
	}
}

/*
실행 결과
3
kim
lee
hong
*/
```

### List 인터페이스 사용

```java
public class ListExam02 {
	public static void main(String[] args) {
		List<String> list = new ArrayList<>();
		list.add("kim");
		list.add("lee");
		list.add("hong");
		
		String str1 = list.get(0); // 형변환 불필요
		String str2 = list.get(1);
		String str3 = list.get(2);
		
		System.out.println(str1);
		System.out.println(str2);
		System.out.println(str3);
	}
}

/*
실행 결과
kim
lee
hong
*/
```

## Set

### HashSet

```java
public class SetExam {
	public static void main(String[] args) {
		Set<String> set = new HashSet<>();
		set.add("hello");
		set.add("hi");
		set.add("hong");
		
		Iterator<String> iter = set.iterator();
		while (iter.hasNext()) {
			String str = iter.next();
			System.out.println(str);
		}
	}
}

/*
실행 결과
hong
hi
hello
*/
```

- 특징
    - 중복된 값을 추가해도 하나만 저장된다.
    - 순서를 보장하지 않는다. (HashSet)

## Map

### HashMap

```java
public class MapExam {
	public static void main(String[] args) {
		Map<String, String> map = new HashMap<>();
		map.put("k1", "hello");
		map.put("k2", "hi");
		map.put("k3", "안녕");
		
		System.out.println(map.get("k1"));
		System.out.println(map.get("k2"));
		System.out.prinltn(map.get("k3"));
		
		// 모든 키-값 쌍 출력하기
		Set<String> keySet = map.keySet();
		Iterator<String> iterator = keySet.iterator();
		while (iterator.hasNext()) {
			String key = iterator.next();
			String value = map.get(key);
			
			System.out.println(key + " : " + value);
		}
	}
}

/*
실행 결과
hello
hi
안녕
k1 : hello
k2 : hi
k3 : 안녕
*/
```

## Collections 유틸리티 클래스

```java
public class UtilExam {
	public static void main(String[] args) {
		List<String> list = new ArrayList<>();
		list.add("kim");
		list.add("lee");
		list.add("hong");
		
		// 정렬		
		Collections.sort(list);
		
		for (int i = 0; i < list.size(); i++) {
			System.out.println(list.get(i));
		}
		
		// 섞기
		Collecions.shuffle(list);
		
		for (int i = 0; i < list.size(); i++) {
			System.out.println(list.get(i));
		}
	}
}

/*
실행 결과
hong
kim
lee
kim
hong
lee
*/
```

## TreeSet

```java
public class TreeSetExam {
	public static void main(String[] args) {
		Set<String> treeSet = new TreeSet<>();
		treeSet.add("hello");
		treeSet.add("a!!");
		treeSet.add("bcd");
		
		Iterator<String> iter = treeSet.iterator();
		while (iter.hasNext()) {
			String str = iter.next();
			System.out.println(str);
		}
	}
}

/*
실행 결과
a!!
bcd
hello
*/
```

- 특징
    - 자동으로 정렬된 상태를 유지한다.

# ArrayList vs LinkedList

- **ArrayList**
    - 내부적으로 배열을 사용한다.
    - 인덱스를 통한 빠른 접근이 가능하다. (O(1))
    - 중간 삽입/삭제 시 요소 이동이 필요하다. (O(n))
- **LinkedList**
    - 노드들이 연결된 구조이다.
    - 순차 접근이 필요하다. (O(n))
    - 중간 삽입/삭제가 빠르다. (O(1))
- 비교 예제
    
    ```java
    public class ListPerformanceComparison {
    	public static void main(String[] args) {
        List<Integer> arrayList = new ArrayList<>();
        List<Integer> linkedList = new LinkedList<>();
    
        System.out.println("=== 끝에 추가 ===");
        // 1. 끝에 추가 (둘 다 빠르다.)
        long startTime = System.currentTimeMillis();
        for (int i = 0; i < 100000; i++) {
            arrayList.add(i);
        }
        long endTime = System.currentTimeMillis();
        System.out.println("ArrayList add Time: " + (endTime - startTime) + "ms");
    
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 100000; i++) {
            linkedList.add(i);
        }
        endTime = System.currentTimeMillis();
        System.out.println("LinkedList add Time: " + (endTime - startTime) + "ms");
    
        System.out.println("=== 중간 삽입 ===");
        // 2. 중간에 삽입 (LinkedList 유리)
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 100000; i++) {
            arrayList.add(50000, i);
        }
        endTime = System.currentTimeMillis();
        System.out.println("ArrayList insert Time: " + (endTime - startTime) + "ms");
    
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 100000; i++) {
            linkedList.add(50000, i);
        }
        endTime = System.currentTimeMillis();
        System.out.println("Linked insert Time: " + (endTime - startTime) + "ms");
    
        System.out.println("=== 인덱스 접근 ===");
        // 3. 인덱스 접근 (ArrayList 유리)
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 100000; i++) {
            arrayList.get(i);
        }
        endTime = System.currentTimeMillis();
        System.out.println("ArrayList Time: " + (endTime - startTime) + "ms");
    
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 100000; i++) {
            linkedList.get(i);
        }
        endTime = System.currentTimeMillis();
        System.out.println("ArrayList Time: " + (endTime - startTime) + "ms");
    	}
    }
    
    /*
    실행 결과
    === 끝에 추가 ===
    ArrayList add Time: 47ms
    LinkedList add Time: 19ms
    === 중간 삽입 ===
    ArrayList insert Time: 4483ms
    Linked insert Time: 25964ms
    === 인덱스 접근 ===
    ArrayList Time: 5ms
    ArrayList Time: 22818ms
    */
    ```
    

# Comparable 과 Comparator

- **Comparable**
    - 객체의 기본 정렬 기준을 정의한다.
    - 정렬 기준을 객체 자신이 가지고 있다.
    - `compareTo()` 메서드를 오버라이딩 해서 구현한다.
    
    ```java
    public class Student implements Comparable<Student> {
    	private String name;
    	private int score;
    	
    	public Student(String name, int score) {
    		this.name = name;
    		this.score = score;
    	}
    	
    	// 기본 정렬: 점수 기준 내림차순
    	@Override
    	public int compareTo(Student other) {
    		return other.score - this.score; // 내림차순
    		// return this.score - other.score; // 오름차순
    	}
    	
    	public String getName() {
    		return name;
    	}
    	
    	public int getScore() {
    		return score;
    	}
    	
    	@Override
    	public String toString() {
    		return name + "(" + score ")";
    	}
    }
    ```
    
- **Comparator**
    - 외부에서 별도의 정렬 기준을 정의한다.
    - 여러 기준으로 정렬하고 싶을 때 유용하다.
    - `compare()` 메서드를 오버라이딩 해서 구현한다.
    
    ```java
    public class ComparatorExample {
    	public static void main(String[] args) {
    		List<Student> students = new ArrayList<>();
    		students.add(new Student("김철수", 85));
    		students.add(new Student("이영희", 92));
    		students.add(new Student("박민수", 78));
    		students.add(new Student("정수진", 92));
    		
    		// 1. Comparable을 이용한 기본 정렬 (점수 내림차순)
    		Collections.sort(students);
    		System.out.println("점수 내림차순: " + students);
    		
    		// 2. Comparator를 이용한 이름순 정렬
    		Collections.sort(students, new Comparator<Student>() {
    			@Override
    			public int compare(Student s1, Student s2) {
    				return s1.getName().compareTo(s2.getName());
    			}
    		});
    		System.out.println("이름 오름차순: " + students);
    		
    		// 3. Lambda를 이용한 간단한 표현 (Java 8+)
    		Collections.sort(students, (s1, s2) -> s1.getScore() - s2.getScore());
    		System.out.println("점수 오름차순: " + students);
    		
    		// 4. Comparator의 정적 메서드 활용 (Java 8+);
    		students.sort(Comparator.comparing(Student::getName).reversed());
    		System.out.println("이름 내림차순: " + students);
    		
    		// 5. 복합 정렬: 점수로 먼저, 같으면 이름으로
    		students.sort(Comparator.comparing(Student::getScore)
    														.thenComparing(Student::getName));
    		System.out.println("점수 후 이름순: " + students);
    	}
    }
    
    /*
    실행 결과
    점수 내림차순: [이영희(92), 정수진(92), 김철수(85), 박민수(78)]
    이름 오름차순: [김철수(85), 박민수(78), 이영희(92), 정수진(92)]
    점수 오름차순: [박민수(78), 김철수(85), 이영희(92), 정수진(92)]
    이름 내림차순: [정수진(92), 이영희(92), 박민수(78), 김철수(85)]
    점수 후 이름순: [박민수(78), 김철수(85), 이영희(92), 정수진(92)]
    */
    ```
    
- Comparable과 Comparator 둘 다 있을 경우 Comparator가 우선순위를 가진다.

---

# 날짜와 시간 API

## 레거시 API (java.util)

```java
public class LegacyDateExample {
	public static void main(String[] args) {
		// Date 클래스
		Date now = new Date();
		System.out.println("현재 시간: " + now);
		
		// 포맷팅
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		System.out.println("포맷팅: " + sdf.format(now));
		
		// Calendar 클래스
		Calendar cal = Calendar.getInstance();
		int year = cal.get(Calendar.YEAR);
		int month = cal.get(Calendar.MONTH) + 1; // 0부터 시작
		int day = cal.get(Calendar.DAY_OF_MONTH);
		
		System.out.printf("오늘: %d년 %d월 %d일\n", year, month, day);
		
		// 날짜 연산
		cal.add(Calendar.DAY_OF_MONTH, 7); // 7일 후
		cal.add(Calendar.MONTH, -1); // 1달 전
		
		Date result = cal.getTime();
		System.out.println("계산 결과: " + sdf.format(result));
	}
}
```

## 최신 API (java.time) - Java 8+

```java
public class LocalDateTimeExample {
	public static void main(String[] args) {
		// 현재 날짜/시간
		LocalDate date = LocalDate.now();
		LocalTime time = LocalTime.now();
		LocalDateTime dateTime = LocalDateTime.now();
		
		System.out.println("날짜: " + date);
		System.out.println("시간: " + time);
		System.out.println("날짜시간: " + dateTime);
		
		// 특정 날짜/시간 생성
		LocalDate birthday = LocalDate.of(2000, 1, 1);
		LocalTime noon = LocalTime.of(12, 0);
		LocalDateTime appointment = LocalDateTime.of(2024, 12, 25, 18, 30);
		
		// 날짜 연산
		LocalDate tomorrow = date.plusDays(1);
		LocalDate lastWeek = date.minusWeeks(1);
		LocalDate nextMonth = date.plusMonths(1);
		
		// 날짜 정보 추출
		int year = date.getYear();
		Month month = date.getMonth();
		int dayOfMonth = date.getDayOfMonth();
		DayOfWeek dayOfWeek = date.getDayOfWeek();
		
		System.out.printf("%d년 %s %d일 %s\n", year, month, dayOfMonth, dayOfWeek);
		
		// 포맷팅
		DateTimeFormatter formatter = 
				DateTimeFormatter.ofPattern("yyyy년 MM월 dd일 HH:mm:ss");
		String formatted = dateTime.format(formatter);
		System.out.println("포맷팅: " + formatted);
		
		// 파싱
		LocalDate parsed = LocalDate.parse("2024=04-10");
		LocalDateTime parsedDT = LocalDateTime.parse("2024-04-10T15:30:45");
	}
}
```

### ZonedDateTime (시간대 포함)

```java
public class ZonedDateTimeExample {
	public static void main(String[] args) {
		// 현재 시간대의 날짜시간
		ZonedDateTime now = ZonedDateTime.now();
		System.out.println("현재(서울): " + now);
		
		// 다른 시간대로 변환
		ZonedDateTime newYork = now.withZoneSameInstant(
				ZoneId.of("America/New_York"));
		System.out.prinltn("뉴욕: " + newYork);
		
		// 특정 시간대로 생성
		ZonedDateTime paris = ZonedDateTime.of(
				LocalDateTime.now(), ZoneId.of("Europe/Paris"));
		
		// 사용 가능한 시간대 확인
		Set<String> zoneIds = ZoneId.getAvailableZoneIds();
		zoneIds.stream()
						.filter(z -> z.contains("Seoul"))
						.forEach(System.out::println);
	}
}
```

### Period와 Duration

```java
public class PeriodDurationExample {
	public static void main(String[] args) {
		// Period - 날짜 간격
		LocalDate birth = LocalDate.of(2000, 1, 1);
		LocalDate today = LocalDate.now();
		
		Period age = Period.between(birth, today);
		System.out.printf("나이: %d년 %d개월 %d일\n", 
				age.getYears(), age.getMonths(), age.getDays());
		
		// Duration - 시간 간격
		LocalTime start = LocalTime.of(9, 0);
		LocalTime end = LocalTime.of(17, 30);
		
		Duration workTime = Duration.between(start, end);
		System.out.println("근무 시간: " + workTime.toHours() + "시간 " + 
				(workTime.toMinutes() % 60) + "분");
		
		// Instant - 타임스탬프
		Instant instant = Instant.now();
		System.out.println("타임스탬프: " + instant);
		System.out.println("에포크 초: " + instant.getEpochSecond());
	}
}
```
