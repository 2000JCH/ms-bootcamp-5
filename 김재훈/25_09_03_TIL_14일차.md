# 예외 처리

## **예외 처리란?**

- 프로그램 실행 중에 발생할 수 있는 **예상치 못한 상황(예외)**에 대비하여 프로그램의 정상적인 흐름을 유지하고 예외 상황을 안전하게 처리하는 프로그래밍 기법

## **예외 처리가 필요한 이유**

1. 프로그램의 안정성과 신뢰성 보장
    - 예외 처리를 통해 프로그램이 예상치 못한 상황에서도 중단되지 않고 계속 실행될 수 있다.
2. 오류의 조기 발견 및 대응
    - 오류 메시지를 통해 문제가 발생한 원인과 위치를 파악할 수 있다.
3. 사용자 경험 개선
    - 적절한 예외 처리로 사용자에게 명확하고 이해하기 쉬운 피드백을 제공할 수 있다.
4. 시스템 자원의 안전한 관리
    - `finally` 블럭이나 `try-with-resources`를 통해 필수적인 자원 해제 작업을 보장한다.
    - `try-with-resources`는 자원 해제를 자동으로 처리하는 문법으로, `AutoCloseable`을 구현한 클래스만 사용이 가능하다.

## 예외 처리를 하지 않으면 발생하는 문제

- 프로그램이 비정상적으로 중단된다.
- 데이터 손실이 발생할 수 있다.
- 보안 취약점이 노출될 수 있다.
- 사용자 경험이 저하된다.

```java
public class WithoutExceptionHandling {
	public static void main(String[] args) {
		int[] numbers = {1, 2, 3};
		System.out.println(numbers[3]); // ArrayIndexOutOfBoundsException 발생!
		System.out.prinltn("프로그램 종료"); // 실행되지 않음
	}
}
```

# Error와 Exception

## 프로그램 오류의 종류

- **컴파일 에러**
    - 컴파일시 발생하는 에러
    - 문법 오류, 타입 불일치 등
- **런타임 에러**
    - **실행시 발생하는 에러**
    - 메모리 부족, 0으로 나누기 등

## 자바 실행시 오류 분류

- **Error**: 수습할 수 없는 시스템 레벨의 심각한 오류로 복구가 불가하다.
    - 메모리 부족(`OutOfMemoryError`), 스택오버플로우(`StackOverflowError`) 등이 발생하여 프로그램이 죽는 것은 프로그래머가 제어할 수 없다.
- **Exception(예외)**: 예외 처리를 통해 개발자가 수습할 수 있는 오류로 복구가 가능하다.
    - **RuntimeException**: 실행 중 발생하며 예외 처리가 강제되지는 않아 선택적으로 처리한다.

# 예외 처리 기본

## 예외가 발생하는 코드

```java
public class Exception1 {
	public static void main(String[] args) {
		ExceptionObj1 exobj = new ExceptionObj1();
		int value = exobj.divide(10, 0);
		System.out.println(value);
	}
}

class ExceptionObj1 {
	public int divide(int i, int k) {
		int value = 0;
		value = i / k; // 0으로 나누기 - ArithmeticException 발생!
		return value;
	}
}
```

- `ArithmeticException`을 발생시켜 프로그램이 비정상 종료된다.

## try-catch 문법

```java
try {
	코드1
	코드2
	...
} catch (Exception클래스명1 변수명1) {
	Exception을 처리하는 코드
} catch (Exception클래스명2 변수명2) {
	Exception을 처리하는 코드
}
```

## try-catch 활용 예제

```java
public class Exception1 {
	public static void main(String[] args) {
		ExceptionObj1 exobj = new ExceptionObj1();
		int value = exobj.divide(10, 0);
		System.out.println(value);
	}
}

class ExceptionObj1 {
	public int divide(int i, int k) {
		int value = 0;
		try {
			value = i / k;
		} catch (ArithmeticException e) {
			System.out.println("0으로 나눌 수 없습니다.");
		} 
		return value;
	}
}
```

# 예외 떠넘기기(throws)

## throws 문법

```java
리턴타입 메서드명(파라미터) throws Exception클래스명1, Exception클래스명2 ... {
	코드1
	코드2
	...
}
```

## throws 활용 예제

```java
public class Exception1 {
	public static void main(String[] args) {
		try {
			ExceptionObj1 exobj = new ExceptionObj1();
			int value = exobj.divide(10, 0);
			System.out.println(value);
		} catch (ArithmeticException e) {
			System.out.println("0으로 나눌 수 없습니다.");
		}
	}
}

class ExceptionObj1 {
	public int divide(int i, int k) throws ArithmeticException {
		int value = 0;
		value = i / k; // 예외가 발생하면 호출한 곳으로 전파
		return value;
	}
}
```

- **try-catch**: 해당 메서드에서 예외를 직접 처리한다.
- **throws**: 예외를 호출한 곳으로 전파하여 처리를 위임한다.

# RuntimeException과 Checked Exception

## 예외 계층 구조

```mathematica
Object
└── Throwable
    ├── Exception
		│		├── SQLException      (체크 예외)
		│		├── IOException       (체크 예외)
		│		└── RuntimeException  (언체크 예외, 런타임 예외)
		│				├── NullPointerException
		│				└── IllegalArgumentException
    └── Error
		    └── OutOfMemoryError
```

<img width="927" height="530" alt="Image" src="https://github.com/user-attachments/assets/167baf05-8521-4a5d-bddd-8da30646586e" />

- **RuntimeException (언체크 예외)**
    - 컴파일러가 예외 처리를 강제하지 않는다.
    - 프로그래머의 실수로 발생하는 예외이다.
    - 예) `NullPointerException`, `ArrayIndexOutOfBoundsException`, `ArithmeticException`
- **Checked Exception (체크 예외)**
    - 컴파일러가 예외 처리를 강제한다.
    - 외부 환경에 의해 발생하는 예외이다.
    - 예) `IOException`, `ClassNotFoundException`, `SQLException`

## Checked Exception 예제

```java
public class Exception4 {
	public static void main(String[] args) /*throws IOException*/ {
		// 컴파일 오류 발생
		// FileInputStream fis = new FileInputStream("Exception5.java");
		
		// 올바른 처리 방법 1: try-catch
		try {
			FileInputStream fis = new FileInputStream("Exception5.java");
		} catch (IOException e) {
			System.out.println("파일을 찾을 수 없습니다.");
		}
		
		// 올바른 처리 방법 2: throws (메서드에 선언)
	}
}
```

# 다중 예외 처리

## 여러 예외를 처리하는 방법

- **다중 catch 주의사항**
    - 구체적인 예외를 먼저 처리해야 한다.
    - `Exception`은 모든 예외의 부모 클래스이므로 가장 마지막에 위치해야한다.
    - 상위 클래스 예외를 먼저 catch하면 하위 클래스 예외는 도달할 수 없다.
    - Java 7 이상에서는 하나의 catch 블럭에서 `|`를 사용하여 여러 예외를 한 번에 처리할 수도 있다.

```java
public class Exception6 {
	public static void main(String[] args) {
		int[] array = {4, 0};
		int[] value = null;
		
		try {
			value[0] = array[0] / array[1];
		} catch (ArrayIndexOutOfBoundsException aiob) {
			System.out.println(aiob.toString());
		} catch (ArithmeticException ae) {
			System.out.println(ae.toString());
		} catch (NullPointerException npe) {
			System.out.pritln("null 참조 오류: " + npe.toString());
		} catch (IOException | SQLException e) { // Java 7+ 여러 예외를 한 번에 처리
			System.out.println("입출력 또는 SQL 예외 발생: " + e.getMessage());
		} catch (Exception e) { // 모든 예외의 부모 클래스이므로 가장 마지막에 위치
			System.out.prinltn("기타 예외: " + e);
		}
	}
}
```

# 사용자 정의 예외

## 사용자 정의 예외 클래스

- `Exception` 상속
    - 복구 가능한 예외를 처리하기 위해 상속하며, 권장되는 방법이다.
- `RuntimeException` 상속
    - 프로그래머의 실수를 예외로 처리하기 위해 상속한다.
    - 무분별한 `RuntimeException` 사용은 예외 추적 및 디버깅을 어렵게 만들 수 있기 때문에 꼭 필요한 경우에만 사용해야 한다.

```java
public class MyException extends RuntimeException {
	public MyException(String msg) {
		super(msg);
	}
	
	public MyException(Exception e) {
		super(e);
	}
}
```

## 사용자 정의 예외 활용

```java
public class Exception7 {
	public static void main(String[] args) {
		try {
			ExceptionObj7 exobj = new ExceptionObj7();
			int value = exobj.divide(10, 0);
			System.out.println(value);
		} catch (MyException e) {
			System.out.println("사용자 정의 Exception이 발생했네요.");
			System.out.println("오류 메시지: " + e.getMessage());
		}
	}
}

class ExceptionObj7 {
	public int divide(int i, int j) throws MyException {
		int value = 0;
		try {
			value = i / j;
		} catch (ArithmeticException ae) {
			throw new MyException("0으로 나눌 수 없습니다.");
		}
		return value;
	}
}
```

## throw와 throws 차이

- **throw**
    - 메서드 내부에서 예외를 실제로 발생시킬 때 사용한다.
    - 예외를 강제로 발생시킨다. (`throw new Exception()`)
- **throws**
    - 메서드 선언부에 사용하며, 해당 메서드가 예외를 던질 수 있다는 것을 알린다.
    - 메서드가 예외를 던질 수 있다는 것을 선언한다. (`method() throws Exception`)

# 예외 처리 모범 사례

## 예외 처리 원칙

1. **구체적인 예외를 처리하라**
    
    ```java
    // 좋지 않음
    catch (Exception e) {}
    
    // 권장
    catch (FileNotFoundException e) {}
    catch (IOException e) {}
    ```
    
2. **예외를 무시하지 마라**
    
    ```java
    // 매우 나쁨
    catch (Exception e) {}
    
    // 권장
    catch (Exception e) {
    	System.err.println("예외 발생: " + e.getMessage());
    	e.printStackTrace();
    	// 또는 로깅 프레임워크 사용
    	// logger.error("예외 발생", e);
    }
    ```
    
3. **리소스는 finally 또는 try-with-resources로 정리하라**
    
    ```java
    // finally 사용
    FileInputStream fis = null;
    try {
    	fis = new FileInputStream("file.txt");
    	// 파일 처리
    } catch (IOException e) {
    	// 예외 처리
    } finally {
    	if (fis != null) {
    		try {
    			fis.close();
    		} catch (IOEcxeption e) {
    			// 로그 출력
    		}
    	}
    }
    ```
    

## try-with-resources

- Java 7부터 도입된 기능으로, `AutoCloseable` 또는 `Closeable` 인터페이스를 구현한 클래스에서 사용 가능하며, 리소스를 자동으로 해제한다.
- 대표적으로 `FileInputStream`, `BufferedReader`, `Scanner`, `Connection`, `PreparedStatement`, `ResultSet` 등에 사용 가능하다.
- 자바 9부터는 try 블럭 외부에서 선언한 변수도 자원으로 사용할 수 있다.
- 문법
    
    ```java
    // Java 7+ 권장 방법
    try (FileInputStream fis = new FileInputStream("file.txt")) {
    	// 파일 처리
    } catch (IOException e) {
    	// 예외 처리
    }
    // 자동으로 fis.close() 호출
    ```
    
- 예제
    
    ```java
    public class TryWithResourcesExample {
    	public static void main(String[] args) throws FileNotFoundException {
    		// 자바 9+ try 블럭 외부에서 선언한 변수도 자원으로 사용 가능
    		BufferedReader br = new BufferedReader(new FileReader("file.txt"));
    		// 파일 복사 예제
    		try (br;
    					FileInputStream fis = new FileInputStream("input.txt");
    					FileOutputStream fos = new FileOutputStream("output.txt");
    					BufferedInputStream bis = new BufferedInputStream(fis);
    					BufferedOutputStream bos = new BufferedOutputStream(fos)) {
    					
    					int data;
    					while ((data = bis.read()) != -1) {
    						bos.write(data);
    					}
    					System.out.println("파일 복사 완료");
    		} catch (IOException e) {
    			System.err.println("파일 처리 중 오류: " + e.getMessage());
    		}
    		// 모든 리소스가 자동으로 close()
    	}
    }
    ```
    

# 사용자 정의 예외 Best Practice

## 효과적인 사용자 정의 예외 설계

1. **의미 있는 이름 사용**
    
    ```java
    public class InsufficientBalanceException extends Exception {
    	private double balance;
    	private double withdrawAmount;
    	
    	public InsufficientBalanceException(double balance, double withdrawAmount) {
    		super(String.format("잔액 부족: 현재 잔액 %.2f원, 출금 시도 %.2f원", 
    												balance, withdrawAmount));
    		this.balance = balance;
    		this.withdrawAmount = withdrawAmount;
    	}
    	
    	public double getBalance() { return balance; }
    	public double getWithdrawAmount() { return withdrawAmount; }
    }
    
    ```
    
2. **계층적 예외 구조**
    
    ```java
    public abstract class BankingException extends Exception {
    	public BankingException(String message) {
    		super(message);
    	}
    }
    
    public class AccountNotFoundException extends BankingException {
    	private String accountNumber;
    	
    	public AccountNotFoundException(String accountNumber) {
    		super("계좌를 찾을 수 없습니다: " + accountNumber);
    		this.accountNumber = accountNumber;
    	}
    }
    
    ```
    
3. **활용 예제**
    
    ```java
    public class BankAccount {
    	private String accountNumber;
    	private double balance;
    	
    	public BankAccount(String accountNumber, double balance) {
    		this.accountNumber = accountNumber;
    		this.balance = balance;
    	}
    	
    	public void withdraw(double amount) throws InsufficientBalanceException {
    		if (amount > balance) {
    			throw new InsufficientBalanceException(balance, amount);
    		}
    		balance -= amount;
    	}
    	
    	public static void main(String[] args) {
    		BankAccount account = new BankAccount("123-456", 10000);
    		
    		try {
    			account.withdraw(15000);
    		} catch (InsufficientBalanceException e) {
    			System.out.println("출금 실패: " + e.getMessage());
    			System.out.println("현재 잔액: " + e.getBalance());
    			System.out.println("출금 시도액: " + e.getWithdrawAmount());
    		}
    	}
    }
    ```
    
- **사용자 정의 예외 가이드라인**
    - `Exception` vs `RuntimeException` 상속 선택
        - 복구 가능한 예외: `Exception` 상속
        - 프로그래밍 오류: `RuntimeException` 상속
    - 의미 있는 정보 포함
    - 예외 발생 시점의 상태 정보 저장
    - 디버깅에 도움이 되는 컨텍스트 제공
    - 표준 예외 재사용 고려
        - `IllegalArgumentException`, `IllegalStateException` 등 표준 예외 활용

# 예외 정보 얻기

## 예외 정보를 얻어야 하는 이유

- **문제의 원인 파악**
    - 예외 정보에는 예외가 발생한 원인에 대한 상세한 설명이 포함되어 있다.
- **정확한 디버깅**
    - 예외가 발생한 코드의 위치(파일명, 라인 번호)를 파악할 수 있다.
- **효율적인 문제 해결**
    - 예외의 종류와 메시지를 이해하면 더 효율적으로 문제를 해결할 수 있다.

## 예외 정보 얻기 예제

```java
public class ExceptionInformation {
	public static void main(String[] args) {
		try {
			int[] numbers = new int[5];
			// 의도적으로 예외 발생(배열의 범위를 넘어서는 접근)
			int number = numbers[10];
		} catch (ArrayIndexOutOfBoundsException e) {
			System.out.println("예외가 발생했습니다.");
			System.out.println("예외 메시지: " + e.getMessage());
			System.out.println("스택 트레이스: ")
			e.printStackTrace();
			System.out.println("예외 발생 위치: " + e.getStackTrace()[0]);
		}
	}
}
```

- `getClass().getName()`: 예외 클래스명을 확인할 수 있다.
- `getMessage()`: 예외에 대한 기본적인 설명 메시지 반환
- `printStackTrace()`: 예외 발생 시 전체 호출 스택을 출력한다. (디버깅용)
- `getStackTrace()`: 예외가 발생한 위치의 상세한 정보를 배열로 제공한다.

---

# IO

## Java IO가 필요한 이유

- 자바에서의 입출력(IO)은 프로그램이 외부 세계와 상호작용하는 핵심 기능이다.
- 필요한 상황들
    - 사용자로부터 키보드 입력 받기 - 화면에 결과 출력하기 - 파일에 데이터 저장하고 읽기 - 네트워크를 통한 데이터 전송 - 데이터베이스와의 통신

## Java IO의 설계 철학

1. **유연성 (Flexibility)**
    - 다양한 데이터 소스와 대상을 지원한다.
    - 파일, 네트워크, 메모리 등을 동일한 인터페이스로 처리할 수 있다.
    - 코드의 재사용성이 향상된다.
2. **확장성 (Extensibility)**
    - 새로운 입출력 타입을 쉽게 추가할 수 있다.
    - 사용자 정의 스트림을 구현할 수 있다.
    - 데코레이터 패턴을 통한 기능 확장이 가능하다.
3. **재사용 가능성 (Reusability)**
    - 일관된 클래스 구조로 재사용이 가능하다.
    - 한 번 작성한 코드를 다양한 상황에서 재사용할 수 있다.
    - 유지보수가 용이하다.

## Java IO의 설계 패턴

- **Decorator 패턴**
    - Java IO는 Decorator 패턴으로 설계되어, 조립되어 사용되도록 만들어졌다.
    
    <img width="721" height="430" alt="Image" src="https://github.com/user-attachments/assets/33a4f13c-390a-43b6-b386-7a5efbd78336" />
    
- **주인공과 장식의 구분**
    - Java IO를 이해하는 핵심은 **주인공**과 **장식**을 구분하는 것이다.
    - **장식 (Decorator)**
        - `InputStream`, `OutputStream`, `Reader`, `Writer`를 생성자에서 받아들인다.
        - 다양한 방식으로 읽고 쓰는 메서드를 가진다.
        - 기본 기능을 확장하거나 개선한다.
    - **주인공 (주 구성요소)**
        - 어떤 대상에게서 읽어들일지, 쓸지를 결정한다.
        - `1byte` 또는 `byte[]` 단위로 읽고 쓰는 메서드를 가진다.
        - `1char` 또는 `char[]` 단위로 읽고 쓰는 메서드를 가진다.
- 구분 방법
    - 생성자를 보면 주인공과 장식을 쉽게 구분할 수 있다.
    - 장식은 다른 IO 객체를 생성자 매개변수로 받아야 한다.

# 스트림(Stream)

## 스트림이란?

- 데이터가 흐르는 통로를 추상화한 개념이다. 물이 파이프를 통해 흐르듯이, 데이터가 스트림을 통해 이동한다.

<aside>

[데이터 소스] → [입력 스트림] → [프로그램] → [출력 스트림] → [데이터 대상]

</aside>

## 클래스 계층 구조

<img width="690" height="393" alt="Image" src="https://github.com/user-attachments/assets/cf7435e4-5f1c-4e5c-8733-f2ef566b2cf7" />

- Java IO는 크게 4가지 추상 클래스를 중심으로 구성된다.
    - **InputStream**: 바이트 단위 입력
    - **OutputStream**: 바이트 단위 출력
    - **Reader**: 문자 단위 입력
    - **Writer**: 문자 단위 출력
- **데이터 단위에 따른 분류**
    - 바이트 스트림 (Byte Stream): 1바이트 단위로 처리
    - 문자 스트림(Character Stream): 2바이트(char) 단위로 처리
- **데이터 흐름에 따른 분류**
    - 입력 스트림 (InputStream): 데이터를 읽어오는 스트림
    - 출력 스트림(OutputStream): 데이터를 내보내는 스트림

# 바이트 단위 입출력 (InputStream/OutputStream)

## 바이트 스트림의 특징

- 모든 종류의 데이터를 처리할 수 있는 가장 기본적인 스트림이다.
- 이진 데이터 처리에 적합한다. (이미지, 오디오, 비디오 등)
- 1바이트씩 처리하며, 모든 데이터를 바이트로 표현이 가능하다.

## 주요 바이트 스트림 클래스

- **InputStream 계열**
    
    
    | **클래스** | **용도** |
    | --- | --- |
    | FileInputStream | 파일에서 바이트 단위로 읽기 |
    | ByteArrayInputStream | 바이트 배열에서 읽기 |
    | BufferedInputStream | 버퍼를 이용한 효율적인 읽기 |
    | DataInputStream | 기본 데이터 타입 읽기 |
- **OutputStream 계열**
    
    
    | **클래스** | **용도** |
    | --- | --- |
    | FileOutputStream | 파일에 바이트 단위로 쓰기 |
    | ByteArrayOutputStream | 바이트 배열에 쓰기 |
    | BufferedOutputStream | 버퍼를 이용한 효율적인 쓰기 |
    | DataOutputStream | 기본 데이터 타입 쓰기 |

## 바이트 스트림 예제

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class ByteStreamExample {
	public static void main(String[] args) {
		// try-with-resources를 사용한 자동 리소스 관리
		try (FileInputStream fis = new FileInputStream("input.jpg");
				FileOutputStream fos = new FileOutputStream("output.jpg")) {
				
				int byteData;
				// 파일 끝(-1)까지 한 바이트씩 읽기
				while ((byteData = fis.read()) != -1) {
					fos.write(byteData);
				}
				System.out.println("파일 복사 완료");
		
		} catch (IOException e) {
			System.out.println("파일 처리 중 오류: " + e.getMessage());
		}
	}
}
```
