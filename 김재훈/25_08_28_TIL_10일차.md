# System 클래스

- 자바에서 표준 입출력, 메모리 관리, 환경 정보 접근, 프로그램 종료 등의 다양한 기능을 제공하는 유틸리티 클래스이다.
- `java.lang` 패키지에 포함되어 있으며, 정적(static) 필드와 메서드만으로 구성되어 있어 객체를 생성하지 않고 바로 사용할 수 있는 특징이 있다.

## 표준 입출력 스트림

```java
public class SystemIOExample {
	public static void main(String[] args) {
		// 표준 출력
		System.out.println("일반 메시지");
		System.err.println("에러 메시지"); // 빨간색으로 출력
		
		// 표준 입력
		Scanner scanner = new Scanner(System.in);
		System.out.print("이름을 입력하세요: ");
		String name = scanner.nextLine();
		System.out.println("안녕하세요, " + name + "님!");
		scanner.close();
	}
}
```

## 시스템 정보와 유틸리티

```java
public class SystemUtilExample {
	public static void main(String[] args) {
		// 현재 시간 (밀리초)
		long currentMillis = System.currentTimeMillis();
		System.out.println("현재 시간(밀리초): " + currentMillis);
		
		// 나노초 (더 정밀한 시간 측정)
		long nanoTime = System.nanoTime();
		System.out.println("나노시간: " + nanoTime);
		
		// 시간 측정 예제
		long startTime = System.currentTimeMillis();
		// 시간이 걸리는 작업
		for (int i = 0; i < 100000; i++) {
			Math.sqrt(i);
		}
		long endTime = System.currentTimeMillis();
		System.out.println("실행 시간: " + (endTime - startTime) + "ms");
		
		// 시스템 프로퍼티
		System.out.println("Java 버전: " + System.getProperty("java.version"));
		System.out.println("OS: " + System.getProperty("os.name"));
		System.out.println("사용자 홈: " + System.getProperty("user.home"));
		System.out.println("현재 디렉토리: " + System.getProperty("user.dir"));
		
		// 환경 변수
		String path = System.getenv("PATH");
		System.out.println("PATH: " + path);
		
		// 배열 복사 (native 메서드로 빠르다.)
		int[] src = {1, 2, 3, 4, 5};
		int[] dest = new int[5];
		System.arraycopy(src, 0, dest, 0, src.length);
		System.out.println("복사된 배열: " + Arrays.toString(dest));
		
		// 가비지 컬렉션 제안 (강제 실행 아님)
		System.gc();
		
		// 프로그램 종료
		// System.exit(0); // 정상 종료
		// System.exit(1); // 비정상 종료
	}
}
```

# Wrapper 클래스

- 자바는 객체 지향 언어이지만 자바 안에 객체가 아닌 기본형이 있다. 기본형은 객체가 아니기 때문에 다음과 같은 한계가 있다
    - 객체가 아니기 때문에 객체 지향 언어의 장점을 살리기 어렵다.
    - 예를 들어, 객체가 제공하는 유용한 메서드를 제공할 수 없고, 객체 참조가 필요한 컬렉션 프레임워크를 사용할 수 없다. 추가적으로 제네릭도 사용할 수 없다.
    - 때로 데이터가 ‘**없음**’이라는 상태를 나타낼 필요가 있는데, 기본형은 null 값을 가질 수 없으므로 이런 표현을 할 수 없다.

## 기본형과 Wrapper 클래스

- 자바가 제공하는 기본 래퍼 클래스이며, **불변**이고 `equals`로 비교해야 한다는 특징이 있다.
- 객체 그대로 출력해도 내부의 값을 문자로 출력하도록 `toString()`을 재정의했다.

| **기본형** | **Wrapper 클래스** |
| --- | --- |
| byte | Byte |
| short | Short |
| int | Integer |
| long | Long |
| float | Float |
| double | Double |
| char | Character |
| boolean | Boolean |

## 박싱과 언박싱

- **박싱(Boxing) - 래퍼 클래스 생성**
    - 기본형을 래퍼 클래스로 변경하는 것을 마치 박스에 물건을 넣은 것 같다고 해서 **박싱(Boxing)**이라 한다.
    - `new Integer(10)`은 자바 9부터  제거(deprecated)되어서 직접 사용하면 안된다. 현재는 호환을 위해서만 남아있고, 사용할 경우 IDE에서 경고 문구가 발생한다.
    - 그 대신 `Integer.valueOf(10)`을 사용하면 된다.
        - 내부에서 `new Integer(10)`을 사용해서 객체를 생성하고 돌려준다.
    - 추가로 `Integer.valueOf()`에는 성능 최적화 기능이 있다.
    - 개발자들이 일반적으로 자주 사용하는 -128 ~ 127 범위의 `Integer` 클래스를 미리 생성해준다.
    - 해당 범위의 값을 조회하면 미리 생성된 `Integer` 객체를 반환한다. 해당 범위의 값이 없으면 `new Integer()`를 호출한다.
        - 문자열 풀과 비슷하게 자주 사용하는 숫자를 미리 생성해두고 재사용한다.

- **언박싱(Unboxing) - 기본형으로 변경**
    - 래퍼 클래스에 들어있는 기본형 값을 다시 꺼내는 메서드이다.
    - 박스에 들어있는 물건을 꺼내는 것 같다고 해서 **언박싱(Unboxing)**이라 한다.

- **자동 박싱(Auto-boxing), 자동 언박싱(Auto-Unboxing) (Java 5+)**
    - 기본형을 래퍼 클래스로 변환하거나 또는 래퍼 클래스를 기본형으로 변환하는 일이 자주 발생한다.
    - 이 문제를 해결하기 위해 Java 5부터 오토 박싱(Auto-boxing), 오토 언박싱(Auto-Unboxing)을 지원한다.
    - 컴파일러가 개발자 대신 `valueOf()`, `xxxValue()` 등의 코드를 추가해주는 덕분에 기본형과 래퍼형을 서로 편리하게 변환할 수 있다.

> **참고 - 비교는 equals() 사용**
> 
> - 래퍼 클래스는 객체이기 때문에 `==` 비교를 하면 인스턴스의 참조값을 비교한다.
> - 내부의 값을 비교하도록 `equals()`를 재정의 해두었기 때문에 값을 비교하려면 `equals()`를 사용해야 한다.

```java
public class WrapperExample {
	public static void main(String[] args) {
		// 박싱 (기본형 -> 객체)
		Integer num1 = new Integer(10); // deprecated
		Integer num2 = Integer.valueOf(20); // 권장
		
		// 언박싱 (객체 -> 기본형)
		int value = num1.intValue();
		
		// 자동 박싱/언박싱 (Java 5+)
		Integer num3 = 30; // 자동 박싱
		int value2 = num3; // 자동 언박싱
		
		// 문자열 변환
		int parsed = Integer.parseInt("123");
		String str = Integer.toString(456);
		
		// 진법 변환
		System.out.println(Integer.toBinaryString(10)); // "1010" (2진법)
		System.out.println(Integer.toOctalString(10)); // "12" (8진법)
		System.out.println(Integer.toHexString(10)); // "a" (16진법)
		
		// 다른 진법 파싱
		int binary = Integer.parseInt("1010", 2); // 10
		int octal = Integer.parseInt("12", 8); // 10
		int hex = Integer.parseInt("A", 16); // 10
		
		// 유용한 상수
		System.out.println("int 최대값: " + Integer.MAX_VALUE);
		System.out.println("int 최소값: " + Integer.MIN_VALUE);
		System.out.println("int 크기: " + Integer.SIZE + "bit");
	}
}

/*
실행 결과
1010
12
a
int 최대값: 2147483647
int 최소값: -2147483648
int 크기: 32bit
*/
```

---

# 컬렉션 프레임워크

## 컬렉션 프레임워크란?

- 데이터 집합을 효율적으로 저장하고 조작하기 위한 자료구조 클래스들의 집합이다.
- 배열보다 더욱 유연하고 강력하게 데이터를 다룰 수 있도록 도와주는 핵심 라이브러리이며, `java.util` 패키지에 포함되어 있다.
- 자료구조의 필요성
    - 효율적인 데이터 관리 : 데이터를 체계적으로 관리할 수 있도록 돕는다.
    - 성능 최적화 : 다양한 자료구조를 사용하여 특정 작업에 최적화된 성능을 얻을 수 있다.
    - 재사용성 및 유지보수 : 일관된 인터페이스를 제공하여 코드 재사용성을 높이고 유지보수를 용이하게 한다.
    - 오류 방지 : 일관된 인터페이스와 제네릭을 사용하여 타입 오류를 방지하고 안전한 코드 작성을 돕는다.

## 주요 인터페이스 구조


```mathematica
Collection<E> (인터페이스)
├── List<E>       : 순서 O, 중복 O
│   ├── ArrayList<E>
│   └── LinkedList<E>
├── Set<E>        : 순서 X, 중복 X
│   ├── HashSet<E>
│   └── TreeSet<E>
└── Queue<E>      : 선입선출 (FIFO)
    └── LinkedList<E>

Map<K, V>         : 키-값 쌍 저장
├── HashMap<K, V>
└── TreeMap<K, V>
```

- **Collection 인터페이스** : `List`, `Set`, `Queue`
    - **List** : 순서가 있는 데이터 집합으로, 중복을 허용한다. `ArrayList`, `LinkedList`
    - **Set** : 순서를 유지하지 않으며, 중복을 허용하지 않는다. `HashSet`, `TreeSet`
    - **Queue** : FIFO(First In First Out) 구조를 가진다. `LinkedList`, `PriorityQueue`
- **Map 인터페이스** : 키와 값의 쌍으로 데이터를 저장한다. `HashMap`, `TreeMap`, `LinkedHashMap`

## 클래스 관계와 특징

- `ArrayList` 와 `LinkedList`
    - `List` 인터페이스를 구현한다.
    - `ArrayList`는 내부적으로 배열을 사용하여 인덱스를 통한 빠른 접근이 가능하다.
    - `LinkedList`는 연결 리스트를 기반으로 하여 데이터 삽입 및 삭제가 빠르다.
- `HashSet` 과 `TreeSet`
    - `Set` 인터페이스를 구현한다.
    - `HashSet`은 해시 테이블을 사용하여 빠른 접근 속도를 제공한다.
    - `TreeSet`은 레드-블랙 트리 구조를 사용하여 정렬된 상태를 유지한다.
- `HashMap` 과 `TreeMap`
    - `Map` 인터페이스를 구현한다.
    - `HashMap`은 해시 테이블을 사용하여 키-값 쌍을 관리한다.
    - `TreeMap`은 키가 정렬된 상태로 데이터를 저장한다.

## Collection 인터페이스

- 자바의 핵심 인터페이스 중 하나로, 객체들의 집합(컬렉션)을 다루기 위한 기본적인 메서드를 제공한다.
- 자바 컬렉션 프레임워크의 기반을 형성하며, 다양한 컬렉션 클래스들이 이 인터페이스를 구현하고 확장한다.
- 주요 기능
    - 저장과 접근 : 다수의 객체를 저장하고, 저장된 객체들에 접근하는 기능을 제공한다.
    - 크기 조회 : 컬렉션에 저장된 객체의 수를 확인할 수 있는 메서드를 포함한다.
    - 데이터 수정 : 객체의 추가, 삭제와 같은 데이터를 수정하는 기능을 제공한다.
    - 데이터 검색 : 특정 객체가 컬렉션에 존재하는지 확인하는 기능을 제공한다.

## Iterator란?

- 자바의 컬렉션 프레임워크에서 컬렉션에 저장된 요소를 읽거나 제거하는 방법을 제공하는 인터페이스이다.
- 컬렉션 내의 요소를 순차적으로 접근할 수 있으며, 컬렉션의 구조에 관계없이 동일한 방식으로 데이터를 처리할 수 있다.
- 주요 기능
    - 순차적 접근 : 컬렉션 내의 요소를 순서대로 접근한다. 개발자는 컬렉션의 내부 구조를 몰라도 각 요소에 접근할 수 있다.
    - 안전한 요소 제거 : `remove()` 메서드를 사용해 반복 중 요소를 안전하게 제거할 수 있다. 컬렉션을 직접 조작하여 발생할 수 있는 동시성 문제를 방지한다.
    - 단방향 이동 : 컬렉션의 요소를 앞에서 뒤로만 이동하며 접근한다.
- `List` 계열 클래스의 리스트 내 요소들을 순차적으로 접근할 수 있고, `Set` 계열 클래스는 순서가 없지만 요소들을 순회할 수 있다.
- `Map` 계열 클래스는 `keySet`, `entrySet`, `values` 메서드를 통해 반환된 컬렉션을 순회할 수 있다.

### 예제

```java
public class IteratorExample {
	public static void main(String[] args) {
		// ArrayList 생성 및 요소 추가
    ArrayList<String> fruits = new ArrayList<>();
    fruits.add("사과");
    fruits.add("바나나");
    fruits.add("오렌지");
    fruits.add("포도");

    // Iterator를 사용하여 ArrayList 순회
    Iterator<String> iterator = fruits.iterator();
    while (iterator.hasNext()) {
        String fruit = iterator.next();
        System.out.println(fruit);
    }
	}
}

/*
실행 결과
사과
바나나
오렌지
포도
*/
```

### 작동 원리

1. `ArrayList` 인스턴스 `fruits`가 생성되고, 여러 과일 이름이 요소로 추가된다.
2. `fruits` 컬렉션에 대한 `Iterator` 인스턴스 `iterator`가 생성된다.
3. `while` 루프를 사용하여 `iterator`가 가리키는 컬렉션을 순회한다.
    1. `iterator.hasNext()`는 `iterator`가 다음 요소를 가지고 있는지 확인하여 `boolean` 값을 반환한다.
    2. `iterator.next()` 메서드는 컬렉션의 다음 요소를 반환하고, `iterator`의 위치를 다음 요소로 이동시킨다.
4. 순회하는 동안 각 요소가 출력된다.

## Generic

- 객체의 타입을 일반화하여 타입 안정성을 높이고, 재사용성을 높이기 위한 기능이다.
- 클래스나 메서드에 사용할 데이터 타입을 외부에서 지정할 수 있도록 만든 문법이다.
- 컴파일 시점에 타입을 명확하게 지정하여 형변환 없이 안전하게 객체를 사용할 수 있도록 한다.
- 사용 이유
    - 타입 불일치 위험 : `Object`로 다룰 경우 타입 에러가 발생할 위험이 있는데, 컴파일 타임에서 타입 체크가 가능하다.
    - 형변환 필요 : 값을 사용할 때마다 형변환이 필요한 경우를 없애고, 형변환 없이 바로 사용이 가능하다.
    - 코드 재사용 : 하나의 코드로 여러 타입을 처리할 수 있다.
- 사용 예시
    
    ```java
    List<String> names = new ArrayList<>();
    Map<String, Integer> scoreMap = new HashMap<>();
    Set<Double> numbers = new HashSet<>();
    ```
    

## List

### 특징

- 자바 컬렉션 프레임워크의 일부로, 객체의 순서가 있는 자료 구조이다.
- 중복을 허용하며, 인덱스를 이용하여 특정 위치에 접근할 수 있다.
- 순서가 중요하거나 동일 요소의 반복 처리가 필요한 경우 유용하게 사용된다.
- 주요 클래스
    - **ArrayList**
        - 내부적으로 동적 배열을 사용하여 요소를 저장한다.
        - 인덱스를 통한 빠른 접근이 가능하며, 요소 추가 및 삭제 시 다른 요소들의 이동이 필요할 수 있다.
    - **LinkedList**
        - 이중 연결 리스트를 사용하여 요소를 관리한다.
        - 요소의 추가와 삭제는 빠르지만, 임의 접근에는 상대적으로 시간이 더 걸린다.
    - **Vector**
        - `ArrayList`와 유사하지만, 스레드에 안전한 방식으로 구현되어 있다.
        - 이러한 이유로 멀티스레드 환경에서 사용하기 적합하지만, 성능이 다소 느릴 수 있다.
    - **Stack**
        - `Vector`를 상속받은 클래스이다.
        - 후입선출(FILO) 방식의 데이터 처리에 사용된다.

### 예제 코드

```java
public class ListExample {
	public static void main(String[] args) {
    // ArrayList 생성
    List<String> fruits = new ArrayList<>();

    // 요소 추가
    fruits.add("Apple");
    fruits.add("Banana");
    fruits.add("Cherry");

    // 요소 접근
    String firstFruit = fruits.get(0);
    System.out.println("첫 번째 과일: " + firstFruit);

    // 요소 수정
    fruits.set(1, "BlueBerry");

    // 요소 삭제
    fruits.remove("Cherry");

    // 리스트 출력
    System.out.println("업데이트 된 과일 리스트: " + fruits);
	}
}

/*
실행 결과
첫 번째 과일: Apple
업데이트 된 과일 리스트: [Apple, BlueBerry]
*/
```

## Set

### 특징

- 순서를 보장하지 않으며, 같은 요소의 중복을 허용하지 않는다.
- 중복되지 않는 유일한 요소들을 저장하는 데 사용한다.
- 어떤 요소가 특정 집합(Set)에 속하는지를 판별할 때 주로 사용한다.
- 객체에 `equals() and hashCode()`를 오버라이드하지 않으면 동등성 비교를 할 수 없다.
- 주요 클래스
    - **HashSet**
        - 가장 널리 사용되는 `Set` 구현체이다.
        - 내부적으로 `HashMap`을 사용하여 요소를 저장한다.
        - 순서를 보장하지 않으며, 빠른 검색 속도를 제공한다.
    - **LinkedHashSet**
        - `HashSet`과 유사하지만, 요소를 삽입된 순서대로 유지한다.
        - `LinkedList`의 형태로 데이터를 저장하여 순서를 보존한다.
    - **TreeSet**
        - 레드-블랙 트리(Red-Black tree) 데이터 구조를 기반으로 한다.
        - 요소들을 정렬된 순서대로 저장하고, 검색, 삭제, 삽입 작업을 효율적으로 수행한다.

### 예제 코드

```java
public class SetExample {
	public static void main(String[] args) {
    // HashSet 생성
    Set<String> fruitSet = new HashSet<>();

    // 요소 추가
    fruitSet.add("사과");
    fruitSet.add("바나나");
    fruitSet.add("키위");
    fruitSet.add("바나나"); // 중복 요소 추가 시도

    // 요소 출력
    System.out.println("과일 집합: " + fruitSet); // 중복을 허용하지 않는 것을 확인할 수 있다.

    // 특정 요소 포함 여부 확인
    if (fruitSet.contains("키위")) {
        System.out.println("키위가 있습니다.");
    }

    // 요소 제거
    fruitSet.remove("바나나");
    System.out.println("바나나 제거 후: " + fruitSet);

    // 집합의 크기
    System.out.println("집합의 크기: " + fruitSet.size());
	}
}

/*
실행 결과
과일 집합: [사과, 키위, 바나나]
키위가 있습니다.
바나나 제거 후: [사과, 키위]
집합의 크기: 2
*/
```

## Map

### 특징

- 키(Key)와 값(Value)의 쌍으로 데이터를 저장하는 자료구조이다.
- 각 키는 고유하며, 이를 통해 해당 키에 매핑된 값을 검색할 수 있다.
- 마치 사전처럼 키를 이용해 빠르게 데이터를 찾을 수 있다.
- 고유한 키
    - 하나의 키는 오직 하나의 값을 가리킬 수 있으며, 각 키는 중복될 수 없다.
    - 중복된 키를 저장할 경우 해당 키의 값이 나중에 저장한 값으로 변경된다.
- 값의 매핑
    - 키를 사용하여 값을 저장하고, 나중에 같은 키로 해당 값을 검색할 수 있다.
- 순서의 무관성
    - 요소들의 순서를 보장하지 않으므로, 추가한 순서대로 저장되지 않을 수 있다.
- 주요 클래스
    - **HashMap**
        - 가장 일반적으로 사용되는 `Map` 구현체이다.
        - 해시 테이블을 사용하여 키와 값을 저장한다.
        - 순서를 보장하지 않으며, null 키와 값이 허용된다.
    - **TreeMap**
        - 레드-블랙 트리 기반의 `Map` 구현체이다.
        - 키에 따라 정렬된 순서로 키-값 쌍을 저장한다.
        - 키의 자연 순서에 따라 정렬되거나, 생성자에 제공된 Comparator에 의해 정렬된다.
    - **LinkedHashMap**
        - `HashMap`과 유사하지만, 요소들이 추가된 순서 또는 접근 순서를 유지한다.
        - 순서가 중요한 시나리오에서 사용된다.
    - **Hashtable**
        - `HashMap`과 유사하지만, 동기화를 지원한다.
        - 멀티스레드 환경에서 안전하게 사용할 수 있지만, 일반적으로 `ConcurrentHashMap`을 사용하는 것이 더 바람직하다.

### 예제 코드

```java
public class MapExample {
	public static void main(String[] args) {
    // HashMap 생성
    Map<String, String> phoneBook = new HashMap<>();

    // 전화번호 추가
    phoneBook.put("Kim", "010-1234-5678");
    phoneBook.put("Park", "010-9876-5432");
    phoneBook.put("Lee", "010-5566-7788");

    // 특정 키를 이용해서 전화번호 검색
    String leeNumber = phoneBook.get("Lee");
    System.out.println("Lee의 전화번호: " + leeNumber);

    // keySet 사용
    System.out.println("\n==== keySet ====");
    Set<String> keySet = phoneBook.keySet();
    System.out.println("keyset = " + keySet);
    for (String key : keySet) {
        System.out.println("key = " + key);
    }

    // values 사용
    System.out.println("\n==== values ====");
    Collection<String> values = phoneBook.values();
    System.out.println("values = " + values);
    for (String value : values) {
        System.out.println("value = " + value);
    }

    // 전체 전화번호 목록 출력
    System.out.println("\n전체 전화번호 목록: ");
    for (Map.Entry<String, String> entry : phoneBook.entrySet()) {
        System.out.println(entry.getKey() + ": " + entry.getValue());
    }
	}
}

/*
실행 결과
Lee의 전화번호: 010-5566-7788

==== keySet ====
keySet = [Lee, Kim, Park]
key = Lee
key = Kim
key = Park

==== values ====
values = [010-5566-7788, 010-1234-5678, 010-9876-5432]
value = 010-5566-7788
value = 010-1234-5678
value = 010-9876-5432

전체 전화번호 목록: 
Lee: 010-5566-7788
Kim: 010-1234-5678
Park: 010-9876-5432
*/
```
