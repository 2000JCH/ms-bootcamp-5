# 객체 지향
<br>
<br>

## 객체지향 프로그래밍(OOP)
- 정의 = 독립적이고 자율적인 객체들이 서로 메시지를 주고받으며 협력하여 프로그램을 구성하는 프로그래밍 패러다임
    - 클래스(Class) = 설계 도면
    - 객체(Object)	= 클래스로부터 만들어진 실체
    - 인스턴스(Instance) = 메모리에 생성된 객체
    - 참조 변수(Reference Variable) = 인스턴스를 가리키는 변수

## 객체지향 심화 - 상속
### 수업 코드 1
```java
public class Exam03 {
    public static void main(String[] args) {
        Parent1 p = new Child1(); 
        // 형변환 - 작은 그릇에서 큰 그릇으로 바꿀 때 (묵시적 형변환 가능)
        // 큰그릇 = 부모 / 작은그릇 = 자식

        Object obj = p;  
        // 묵시적 형변환 일어남 (자동 업캐스팅)

        p = (Parent1) obj; 
        // 더 큰 그릇에서 작은 그릇으로 옮겨담기 (다운캐스팅, 가능)

        Child1 c = (Child1) p; 
        // 가능하다 (실제 객체가 Child1 이므로 안전)

        Parent1 pp = new Parent1();

        // 형변환 시에는 인스턴스가 중요함
        if (pp instanceof Child1) {
            Child1 cc = (Child1) pp; 
            // 실행되지 않음 (pp는 Child1 인스턴스가 아님)
        }
    }
}
```

### 수업 코드 2
```java
// 부모 클래스
class Parent1 {
    int i = 10;

    public int getI() {
        return i;
    }
}

// 자식 클래스 (상속)
class Child1 extends Parent1 {
    // 부모가 가진 것을 자식이 다시 정의할 수 있음 (오버라이딩)
    int i = 20;

    @Override
    public int getI() {
        return i;
    }
}
```

### 수업 코드 3
### 수업 코드 3 (오버라이딩 & 다형성 예제)
```java
// 부모 클래스 (Animal)
public class Animal {
    public void makeSound() {
        System.out.println("동물이 소리를 냅니다.");
    }

    public void move() {
        System.out.println("동물이 움직입니다.");
    }
}

// 자식 클래스 (Dog)
public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("멍멍!");
    }

    @Override
    public void move() {
        System.out.println("강아지가 네 발로 뛰어다닙니다.");
    }

    // Dog만의 고유 메소드
    public void wagTail() {
        System.out.println("꼬리를 흔듭니다.");
    }
}

// 자식 클래스 (Cat)
public class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("야옹~");
    }

    @Override
    public void move() {
        System.out.println("고양이가 살금살금 움직입니다.");
    }
}

// 실행 클래스
public class OverrideExam {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.makeSound();   // → "멍멍!"
        dog.move();        // → "강아지가 네 발로 뛰어다닙니다."
        dog.wagTail();     // → "꼬리를 흔듭니다."

        Cat cat = new Cat();
        cat.makeSound();   // → "야옹~"
        cat.move();        // → "고양이가 살금살금 움직입니다."

        // 다형성 활용 (부모 타입 변수로 자식 객체 참조)
        Animal animal1 = new Dog();
        Animal animal2 = new Cat();

        animal1.makeSound(); // 실제 Dog 객체이므로 "멍멍!"
        animal2.makeSound(); // 실제 Cat 객체이므로 "야옹~"
    }
}
```

### 수업 코드 4
```java
public class OverrideExam {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.makeSound();   // → "멍멍!"

        Cat cat = new Cat();
        cat.makeSound();   // → "야옹~"

        // 다형성: 부모 타입 변수로 자식 객체를 참조할 수 있다.
        Animal animal = null;

        // 실행 시 전달된 인자(args[0]) 값에 따라 다른 객체 생성
        if ("1".equals(args[0])) {
            animal = new Cat();
        } else {
            animal = new Dog();
        }

        // 실제 생성된 객체에 따라 오버라이딩된 메소드가 실행된다.
        animal.makeSound(); // Cat → "야옹~", Dog → "멍멍!"
        animal.move();      // Cat → "고양이가 살금살금 움직입니다."
                            // Dog → "강아지가 네 발로 뛰어다닙니다."
    }
}
```
